ç™¾äººåšä½œä¸šä¸“ç”¨



unity fur shader ï¼š[Sorumi/UnityFurShader: ğŸˆ Fur shader for Unity. (github.com)](https://github.com/Sorumi/UnityFurShader)



### 3.1.1 æ·±åº¦æµ‹è¯•





åŸºäºæ¨¡ç‰ˆæµ‹è¯•çš„æ‰©å±•è¿›è¡Œçš„ä½œä¸š

-  æè¾¹
  - [Unity Shader: ç†è§£Stencil bufferå¹¶å°†å®ƒç”¨äºä¸€äº›å®æˆ˜æ¡ˆä¾‹ï¼ˆæè¾¹ï¼Œå¤šè¾¹å½¢å¡«å……ï¼Œåå°„åŒºåŸŸé™å®šï¼Œé˜´å½±ä½“shadow volumeé˜´å½±æ¸²æŸ“ï¼‰_unity stencil buffer-CSDNåšå®¢](https://blog.csdn.net/liu_if_else/article/details/86316361)
  - [ã€Unity URPã€‘2ç§æè¾¹æ–¹æ¡ˆï¼šæ¨¡æ¿æµ‹è¯•å’Œæ­£é¢å‰”é™¤_unity urp æè¾¹-CSDNåšå®¢](https://blog.csdn.net/qq_41835314/article/details/129963711)
- å¤šè¾¹å½¢å¡«å……
- åå°„åŒºåŸŸæ§åˆ¶
- Shadow volumeé˜´å½±æ¸²æŸ“



#### Stencilä¸æè¾¹



##### åŸºäºstencilçš„æè¾¹

![image-20250209160143460](D:/TyporaImage/image-20250209160143460.png)

- ç¬¬ä¸€ä¸ªpass

  - ```C
                Name "ForwardLit"
                Tags {
                    "LightMode"="SRPDefaultUnlit"
                }
                
                // å‰”é™¤æ“ä½œ 
                // Blend [_SrcBlend][_DstBlend]
                // ZWrite[_ZWrite]
                // Cull[_CullMode0]
              
                Stencil {
                    Ref 2           // ç»™æ¨¡æ¿åˆ·å€¼
                    Comp Always     // å§‹ç»ˆæ¸²æŸ“
                    Pass Replace       // é€šè¿‡Compæµ‹è¯•ï¼Œä¸”æŠŠå½“å‰çš„Refå€¼2å†™å…¥Stencil Bufferä¸­
                }
    ```

- ç¬¬äºŒä¸ªPass

  - ```c
                Name "Outline"
                Tags {
                    "LightMode"="UniversalForward"
                }
              
                // // å‰”é™¤
                // Cull [_CullMode1] // Cull Front
              
                Stencil {
                    Ref 2
                    Comp NotEqual // ä¸ç›¸ç­‰æ‰é€šè¿‡ï¼Œé‚£ä¹ˆç›¸ç­‰çš„éƒ½ä¼šè¢«passï¼Œæ‰€ä»¥ç€è‰²åŒºåŸŸä¸ä¼šåšä»»ä½•æ¸²æŸ“ï¼Œå› ä¸ºå‰é¢ç€è‰²åŒºåŸŸReféƒ½æ˜¯2
                    Pass Keep     // Stencil Bufferé»˜è®¤å€¼æ˜¯0ï¼Œæ‰€ä»¥å…¶ä»–åœ°æ–¹å°±ä¿ç•™å•¦
                }
    ```



###### **å¤–æ‰©æ–¹æ³•**

-  **1.åŸºäºæ¨¡å‹ç©ºé—´çš„æ³•çº¿å¤–æ‰©**

  - ![image-20250209160346838](D:/TyporaImage/image-20250209160346838.png)
  - æ•ˆæœ![image-20250209160414272](D:/TyporaImage/image-20250209160414272.png)
  - å› ä¸ºé€è§†æ•ˆæœï¼Œäº§ç”Ÿçš„æè¾¹ä¹Ÿæœ‰è¿‘å¤§è¿œå°çš„é€è§†æ„Ÿ
    - <img src="D:/TyporaImage/image-20250209160541846.png" alt="image-20250209160541846" style="zoom:50%;" />
    - ![image-20250209164036415](D:/TyporaImage/image-20250209164036415.png)

- **2.åŸºäºè£å‰ªç©ºé—´çš„æ³•çº¿å¤–æ‰©**

  - ```c
                v2f vert(a2v v) {
                    v2f o;
              
                    // 1.æ¨¡å‹ç©ºé—´ä¸‹è†¨èƒ€
                    v.positionOS.xyz += v.normalOS * _OutlineStrength * 0.01;
                    // VertexPositionInputs vertexPos = GetVertexPositionInputs(v.positionOS.xyz);
                    // o.positionCS = vertexPos.positionCS;
                    // or:
                    o.positionCS = TransformObjectToHClip(v.positionOS.xyz);
              
                    #ifdef _FIXED_ON
              
                    // 2.è£å‰ªç©ºé—´
                    VertexNormalInputs normalPos = GetVertexNormalInputs(v.normalOS.xyz);
                    float2 normalCS = TransformWorldToHClipDir(normalPos.normalWS).xy; // ä¸–ç•Œç©ºé—´->è£å‰ªç©ºé—´ï¼Œåªç•™ä¸‹xyï¼Œä¸è¦zçš„
                    o.positionCS.xy += normalCS * _OutlineStrength * 0.01 * o.positionCS.w;
              
                    #endif
                    
                    return o;
                }
    ```

    - é‡åˆ°ä¸ªé—®é¢˜ï¼Œå¾ˆå¥‡æ€ªã€‚å¤–æ‰©æ³•çº¿å®ƒä¸ä¼šå‘ç€Zè½´è¿›è¡Œå¤–æ‰©ã€‚

  - åœ¨è£å‰ªç©ºé—´è¿›è¡Œæ³•çº¿å¤–æ‰©ï¼ˆæ„Ÿè§‰æ•ˆæœå¤§å·®ä¸å·®ï¼‰

  - ![image-20250209163945969](D:/TyporaImage/image-20250209163945969.png)![image-20250209164008732](D:/TyporaImage/image-20250209164008732.png)<img src="D:/TyporaImage/image-20250209163914886.png" alt="image-20250209163914886" style="zoom:50%;" />



å½“å¸Œæœ›è¿‘ä¸€ç‚¹çš„è·ç¦»å¯ä»¥ç²—ä¸€ç‚¹ï¼Œä½†æ˜¯å¤ªè¿œä¸è¦é»‘ä¹ä¹ä¸€ç‰‡æ—¶ï¼Œéœ€è¦æ§åˆ¶`o.positionCS.w`çš„å€¼ã€‚ç„¶åå¯ä»¥å®ç°å¯¹è¿œå¤„æè¾¹çš„è‡ªå®šä¹‰æ§åˆ¶ã€‚

- å› ä¸ºè¿™ä¸ªwçš„å€¼æ˜¯å’Œå±å¹•å°ºå¯¸æœ‰å…³çš„<img src="D:/TyporaImage/image-20250209170134938.png" alt="image-20250209170134938" style="zoom:50%;" />
  - æ‰‹åŠ¨å¯¹Wè¿›è¡Œé’³åˆ¶<img src="D:/TyporaImage/image-20250209172724812.png" alt="image-20250209172724812" style="zoom:67%;" />
  - ä¸æ–­åœ°è°ƒæ•´é’³åˆ¶å€¼ï¼Œå¯ä»¥è‡ªå®šä¹‰è¿œå¤„çš„æè¾¹å¼ºåº¦ï¼Œè€Œä¸å½±å“è¿‘å¤„çš„ï¼Œ![åŠ¨ç”»](D:/TyporaImage/%E5%8A%A8%E7%94%BB-1739093448701-1.gif)
- å½“æˆ‘æ²¡æœ‰ä¹˜`o.positionCS.w`æ—¶ï¼Œç¦»çš„å¾ˆè¿œçš„æ—¶å€™å‡ ä¹çœ‹ä¸åˆ°å¤–è½®å»“çº¿äº†ï¼ˆæ¨¡å‹ç©ºé—´ï¼‰
  - ![image-20250209172340714](D:/TyporaImage/image-20250209172340714.png)
- å½“æˆ‘ä¹˜äº†`o.positionCS.w`æ—¶ï¼Œç¦»çš„å¾ˆè¿œçš„æ—¶å€™è¿˜æ˜¯å¯ä»¥ä¿æŒçœ‹åˆ°è½®å»“çº¿ï¼Œè€Œä¸”å¥½åƒç¦»å¾—è¿œè½®å»“çº¿åè€Œå¤§ã€‚å› ä¸ºWçš„å€¼æ˜¯[Near,Far]ã€‚ç›¸æœºè¶Šè¿œçš„æ—¶å€™ï¼Œå€¼è¶Šå¤§ã€‚å¸¦æ¥çš„æ•ˆæœå°±å¯ä»¥æ˜¯ç¦»å¾—è¿œçš„æ—¶å€™æ”¾å¤§å¤–è½®å»“çº¿ã€‚ï¼ˆæ¨¡å‹ç©ºé—´ï¼‰
  - ![image-20250209172417819](D:/TyporaImage/image-20250209172417819.png)



**å¯ä»¥å‘ç°ï¼Œä½¿ç”¨stencialçš„æ–¹æ³•åªèƒ½å®ç°å¤–è½®å»“æè¾¹ã€‚å¯¹äºå†…éƒ¨ç»†èŠ‚çš„æè¾¹æ˜¯æ²¡æœ‰çš„ã€‚**



##### åŸºäºåŒPassçš„å‡ ä½•æè¾¹

- æ€è·¯æ˜¯æŒ‰ç…§ä¹‹å‰çš„Shaderå…¥é—¨ç²¾è¦è¿›è¡Œè°ƒæ•´çš„ï¼Œä¹Ÿæ˜¯åŸºäºæ¨¡å‹ç©ºé—´ã€‚
- ä¹Ÿå¯ä»¥åšåˆ°è¿œè¿‘çš„æè¾¹ç²—ç»†æ›´æ”¹â€”â€”`o.positionCS.w`
  - ![image-20250209173656492](D:/TyporaImage/image-20250209173656492.png)



##### å¤–æ‰©æ–¹å¼çš„æ³•çº¿ç¼ºç‚¹

æœ¬èº«æ˜¯åŸºäºæ³•çº¿çš„ï¼Œæ‰€ä»¥ä¸€å®šä¼šé‡åˆ°è¿™äº›æƒ…å†µï¼š

- å‡¹ä¸‹å»çš„ç‰©ä½“ï¼šæè¾¹ä¼šå¾ˆå¥‡æ€ª

- ä½æ¨¡ï¼šæ¯”å¦‚ä¸€ä¸ªç«‹æ–¹ä½“ã€æ³•çº¿è¿‡æ¸¡å‰§çƒˆçš„è§’è½ï¼Œæè¾¹ä¼šæ–­
- å¦‚æœç©¿é€æ¨¡å‹ï¼Œä¼šå‘ç°å†…éƒ¨ä¸€ç‰‡æ­»é»‘<img src="D:/TyporaImage/image-20250209180825700.png" alt="image-20250209180825700" style="zoom:25%;" />

é’ˆå¯¹ä½æ¨¡è¿™ä¸ªé—®é¢˜ï¼Œéœ€è¦å¯¹æ¨¡å‹åšé¢å¤–çš„æ³•çº¿å¹³æ»‘å¤„ç†ï¼Œè¿™é‡Œå¯ä»¥å•ç‹¬å†™ä¸€ä¸ªè„šæœ¬ï¼Œå®šä¹‰æˆç»„ä»¶ä¹‹åæœ‰é’ˆå¯¹æ€§åœ°å»å¹³æ»‘æ³•çº¿ï¼Œè¿™é‡Œå°±ä¸åœ¨æ‰©å±•äº†ã€‚



#### å¤šè¾¹å½¢å¡«å……

*æ„Ÿè§‰å¯ä»¥ç”¨æ¥åšä¸€äº›æ¥è§¦æ‰å‘å…‰çš„ä¸œè¥¿ï¼Œæ¯”å¦‚çƒ­æˆåƒ*



##### ASEå®ç°å¤šPass

â€‹	ä¸ºäº†å®ç°å¤šè¾¹å½¢å¡«å……çš„å¾ˆå¤šä¸ªpassï¼Œéœ€è¦åœ¨æ­¤å­¦ä¹ å¤špassçš„ä½¿ç”¨æ–¹æ³•ã€‚https://blog.csdn.net/liweizhao/article/details/133719840

1. å¤åˆ¶ç²˜è´´ä¸€ä¸ªå¹¶æ”¹å<img src="D:/TyporaImage/image-20250210113942626.png" alt="image-20250210113942626" style="zoom:50%;" />
2. æ‰¾åˆ°é‡Œé¢çš„passï¼Œæœ‰ä¸ªé¢å¤–çš„pass<img src="D:/TyporaImage/image-20250210114037892.png" alt="image-20250210114037892" style="zoom: 33%;" />
3. å¯¹ä¸€æ•´ä¸ªè¿›è¡Œå¤åˆ¶ç²˜è´´ï¼Œç„¶åç»“å°¾åŠ ä¸Š`/*ase_pass_end*/`ï¼ˆå°è¯•äº†åŠ äº†å’Œæ²¡åŠ æ²¡å•¥åŒºåˆ«ï¼‰![image-20250210114131787](D:/TyporaImage/image-20250210114131787.png)
4. ç„¶åå°±ä¼šå¤šå‡ºæ¥äº†ã€‚éœ€è¦å‡ ä¸ªå°±é‡å¤å‡ æ¬¡ã€‚æ ¹æ®éœ€è¦æˆ‘é¢å¤–åˆ›å»ºäº†ä¸‰ä¸ªpass![image-20250210114346536](D:/TyporaImage/image-20250210114346536.png)



##### å¤šè¾¹å½¢å¡«å……

- æ ¹æ®ä»£ç è¿›è¡Œè¿˜åŸã€‚

  - ```C
    Shader "Unlit/PolygonsBeta"
    {
        Properties
        {
            _MainTex ("Texture", 2D) = "white" {}
        }
        SubShader
        {
            Tags { "RenderType"="Opaque" }
            LOD 100
    
            CGINCLUDE
            #include "UnityCG.cginc"
            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };
    
            struct v2f
            {
                float2 uv : TEXCOORD0;
                UNITY_FOG_COORDS(1)
                float4 vertex : SV_POSITION;
            };
    
            sampler2D _MainTex;
            float4 _MainTex_ST;
            
            v2f vert (appdata v)
            {
                v2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.uv = TRANSFORM_TEX(v.uv, _MainTex);
                UNITY_TRANSFER_FOG(o,o.vertex);
                return o;
            }
            ENDCG
    
            Pass
            {
                Stencil {
                    Ref 0           //0-255
                    Comp always     //default:always
                    Pass IncrWrap       //default:keep
                    Fail keep       //default:keep
                    ZFail IncrWrap  //default:keep
                }
    
                CGPROGRAM
                #pragma vertex vert
                #pragma fragment frag
                // make fog work
                #pragma multi_compile_fog
    
                fixed4 frag (v2f i) : SV_Target
                {
                    // sample the texture
                    fixed4 col = tex2D(_MainTex, i.uv);
                    // apply fog
                    UNITY_APPLY_FOG(i.fogCoord, col);
                    return fixed4(0,0,0,0);
                }
                ENDCG
            }
            
            Pass
            {
                Stencil {
                    Ref 2           //0-255
                    Comp Equal     //default:always
                    Pass keep       //default:keep
                    Fail keep       //default:keep
                    ZFail keep  //default:keep
                }
                CGPROGRAM
                #pragma vertex vert
                #pragma fragment frag
                // make fog work
                #pragma multi_compile_fog
                
                #include "UnityCG.cginc"
    
                fixed4 frag (v2f i) : SV_Target
                {
                    // sample the texture
                    fixed4 col = tex2D(_MainTex, i.uv);
                    // apply fog
                    UNITY_APPLY_FOG(i.fogCoord, col);
                    return fixed4(0.2,0.2,0.2,1);
                }
                ENDCG
            }
    
            Pass
            {
                Stencil {
                    Ref 3          //0-255
                    Comp equal     //default:always
                    Pass keep   //default:keep
                    Fail keep      //default:keep
                    ZFail keep  //default:keep
                }
                CGPROGRAM
                #pragma vertex vert
                #pragma fragment frag
                // make fog work
                #pragma multi_compile_fog
                
                #include "UnityCG.cginc"
    
                fixed4 frag (v2f i) : SV_Target
                {
                    // sample the texture
                    fixed4 col = tex2D(_MainTex, i.uv);
                    // apply fog
                    UNITY_APPLY_FOG(i.fogCoord, col);
                    return fixed4(0.6,0.6,0.6,1);
                }
                ENDCG
            }
    
            Pass
            {
                Stencil {
                    Ref 4          //0-255
                    Comp equal     //default:always
                    Pass keep   //default:keep
                    Fail keep      //default:keep
                    ZFail keep  //default:keep
                }
                CGPROGRAM
                #pragma vertex vert
                #pragma fragment frag
                // make fog work
                #pragma multi_compile_fog
                
                #include "UnityCG.cginc"
    
                fixed4 frag (v2f i) : SV_Target
                {
                    // sample the texture
                    fixed4 col = tex2D(_MainTex, i.uv);
                    // apply fog
                    UNITY_APPLY_FOG(i.fogCoord, col);
                    return fixed4(1,1,1,1);
                }
                ENDCG
            }
        }
    }
    
    ```

  - **å®ç°æ–¹æ³•**ï¼š

    - ä¸‰ä¸ªpasså‡å¼€å¯åŒé¢æ˜¾ç¤º
    - ç¬¬ä¸€ä¸ªpassæŒ‰ç…§ä»£ç è®¾ç½®ï¼Œå¹¶ä¸”ä¿®æ”¹`LightMode = SRPDefaultUnlit`ï¼Œç”±`Pass1`åŠ¨æ€ä¿®æ”¹`Ref`å€¼
      - ![image-20250210132121145](D:/TyporaImage/image-20250210132121145.png)
    - ç¬¬äºŒä¸ªPassï¼Œ`LightMode = UniversalForward`,ç”±`Pass2`åŠ¨æ€ä¿®æ”¹`Ref`å€¼
      - ![image-20250210132216605](D:/TyporaImage/image-20250210132216605.png)
    - ç¬¬ä¸‰ä¸ªPassï¼Œ`LightMode = UniversalForwardOnly`ï¼Œç”±`Pass3`åŠ¨æ€ä¿®æ”¹`Ref`å€¼

- **åœ¨URPçš„ç¯å¢ƒä¸‹å‘ç°ä¸€ä¸ªé—®é¢˜ï¼Œå¦‚æœæ˜¯åŒæ ·çš„LightModeï¼Œæœ‰äº›Passä¸ä¼šè¢«æ¸²æŸ“**

  - ![image-20250210124529835](D:/TyporaImage/image-20250210124529835.png)
  - è¿™åœ¨ä¹‹å‰[Unity URPä¸­çš„Single-Passåˆ°åº•æ˜¯ä»€ä¹ˆ_unity singlepass-CSDNåšå®¢](https://blog.csdn.net/wang568270833/article/details/109426645)æ‰¾åˆ°é—®é¢˜æ‰€åœ¨ã€‚
  - **è§£å†³æ–¹æ³•ï¼š**
    - ä¸ºä¸åŒçš„Passçš„Tagsè®¾ç½®ä¸åŒçš„LightModeã€‚ï¼ˆå®é™…ä¸Šä¹Ÿæ²¡é‚£ä¹ˆå¤šå¯ä»¥è®¾ç½®çš„ï¼‰
  - **å®Œæˆæ•ˆæœï¼š**
    - ä¿®æ”¹ä¸‰ä¸ªå€¼æ–¹ä¾¿è§‚å¯Ÿä¸åŒçš„stencilçš„refå€¼å¸¦æ¥çš„ç©¿æ’å½±å“
    - ä¸¤ä¸ªç©¿æ’è¡¨ç°ä¸ºé»„è‰²ï¼Œä¸‰ä¸ªç©¿æ’è¡¨ç°ä¸ºæµ…è“è‰²ã€‚
    - ![image-20250210132007338](D:/TyporaImage/image-20250210132007338.png)



#### åå°„åŒºåŸŸçš„è£å®š

æ­¤ç”¨æ³•ä¸»è¦æ˜¯è¾…åŠ©ä¸€ä¸ªåå°„shaderï¼Œå¯ä»¥æ¯”è¾ƒç®€å•çš„æ¨¡æ‹Ÿå‡ºä¸€ä¸ªé•œé¢æ•ˆæœã€‚

æ„Ÿè§‰ç”¨å¤„å¥½åƒä¸å¤ªå¤§



####  é˜´å½±ä½“shadow volumeé˜´å½±æ¸²æŸ“

æˆ‘å‘ç°å¦‚æœæˆ‘ä¸æŠŠé¢œè‰²å†™å…¥åˆ°FrameBufferé‡Œé¢ï¼Œç”¨ColorMaské®ç½©é®ä½ï¼Œå°±ä¼šå‡ºç°è¿™ç§æƒ…å†µï¼š![image-20250210141836983](D:/TyporaImage/image-20250210141836983.png)

åŒ…æ‹¬å¦‚æœä½¿å®ƒé€æ˜ã€‚å¥½åƒå®ç°ä¸äº†ï¼Œä¿ç•™äº†ã€‚





### 3.1.2 Z-Testï¼ˆæ·±åº¦æµ‹è¯•ï¼‰

#### 1ã€ä¸‰ä¸ªç«‹æ–¹ä½“é®æŒ¡

![img](D:/TyporaImage/1624715632826-1531c1ec-eb98-4745-923d-725dc92c1284-1739171814860-1.webp)

<img src="D:/TyporaImage/image-20250210152923481.png" alt="image-20250210152923481" style="zoom:67%;" />

![image-20250210152914391](D:/TyporaImage/image-20250210152914391.png)

<img src="D:/TyporaImage/image-20250210153033124.png" alt="image-20250210153033124" style="zoom:67%;" />

<img src="D:/TyporaImage/image-20250210153126727.png" alt="image-20250210153126727" style="zoom:67%;" />

<img src="D:/TyporaImage/image-20250210153150643.png" alt="image-20250210153150643" style="zoom:67%;" />

<img src="D:/TyporaImage/image-20250210153233163.png" alt="image-20250210153233163" style="zoom:67%;" />





#### 2ã€X-Ray

##### å®ç°æ–¹æ³•â‘ 

- **è´Ÿè´£æ¸²æŸ“çš„éƒ¨åˆ†**

  - `RenderType = Transparent`ï¼Œ`Queue = Transparent`
  - `Blend SrcAlpha One`(åšç‰¹æ•ˆç”¨çš„å åŠ å…‰)
  - `Cull Back`
  - `ZWrite Off` `ZTest GEqual`
  - ![image-20250210155236014](D:/TyporaImage/image-20250210155236014.png)

- **å¦ä¸€ä¸ªéƒ¨åˆ†**

  - ä¿æŒé»˜è®¤

    ```C
    Blend One Zero, One Zero
    ZWrite On
    ZTest LEqual
    ```

- **æ•ˆæœ**

  - ![åŠ¨ç”»](D:/TyporaImage/%E5%8A%A8%E7%94%BB-1739174144861-3.gif)



##### å®ç°æ–¹æ³•â‘¡

å‚è€ƒ[Unity URPä¸€åˆ†é’Ÿå®ç°é®æŒ¡é€è§†_urp é€è§†-CSDNåšå®¢](https://blog.csdn.net/farcor_cn/article/details/116197865)

åŸç†å·®ä¸å¤š



#### 3ã€Depth Fade

**Depth Fadeçš„ä»£ç **

```c
float4 screenPos10 = IN.ase_texcoord3;
float4 ase_screenPosNorm10 = screenPos10 / screenPos10.w;	//è½¬åŒ–ä¸ºæ ‡å‡†åŒ–çš„å±å¹•ç©ºé—´åæ ‡ï¼Œå°†é½æ¬¡åæ ‡è½¬æ¢ä¸ºéé½æ¬¡åæ ‡ï¼Œè¿›è¡ŒæŠ•å½±å˜æ¢ï¼Œä»è€Œå¾—åˆ°æ ‡å‡†åŒ–çš„å±å¹•ç©ºé—´åæ ‡ã€‚
ase_screenPosNorm10.z = ( UNITY_NEAR_CLIP_VALUE >= 0 ) ? ase_screenPosNorm10.z : ase_screenPosNorm10.z * 0.5 + 0.5;//åˆ¤æ–­è¿‘è£å‰ªå¹³é¢ï¼Œå¦‚æœæœ‰å€¼å°±ä¿æŒï¼Œå¦åˆ™è¿›è¡Œå½’ä¸€åŒ–å¤„ç†ã€‚å°†[-1,1]è½¬æ¢åˆ°[0,1]
float screenDepth10 = LinearEyeDepth(SHADERGRAPH_SAMPLE_SCENE_DEPTH( ase_screenPosNorm10.xy ),_ZBufferParams);//å°†æ·±åº¦ç¼“å†²åŒºçš„éçº¿æ€§å€¼è½¬æ¢ä¸ºçº¿æ€§è§‚å¯Ÿç©ºé—´æ·±åº¦ï¼ˆå•ä½ä¸ºä¸–ç•Œç©ºé—´è·ç¦»ï¼‰
float distanceDepth10 = saturate( abs( ( screenDepth10 - LinearEyeDepth( ase_screenPosNorm10.z,_ZBufferParams ) ) / ( 1.0 ) ) );//è¡¨ç¤ºå½“å‰åƒç´ ä¸èƒŒæ™¯ä¹‹é—´çš„è·ç¦»æ¯”ä¾‹ï¼Œ0 è¡¨ç¤ºå®Œå…¨è´´åˆï¼Œ1 è¡¨ç¤ºè¾¾åˆ°æœ€å¤§è·ç¦»ã€‚
float3 temp_cast_0 = (( 1.0 - distanceDepth10 )).xxx;
```

- ASEçš„`Depth Fade`èŠ‚ç‚¹å®ç°<img src="D:/TyporaImage/image-20241120173125226.png" alt="image-20241120173125226" style="zoom:33%;" />ï¼Œä½†æ˜¯å¯¹äºæ¸²æŸ“æ¬¡åºä»¥åŠæ··åˆæ¨¡å¼å¾—è°ƒå¯¹ã€‚
  - å¤§æ¦‚çš„æ„æ€å°±æ˜¯ï¼Œé€šè¿‡å°†åœºæ™¯æ·±åº¦ä¸ç‰©ä½“æ·±åº¦åšå·®ï¼Œå¹¶ä¸”é™åˆ¶åˆ°[0,1]ï¼Œå¯ä»¥å®ç°åœ¨ç›¸äº¤çš„éƒ¨åˆ†å‡ºç°å€¼ã€‚
  - éœ€è¦èƒ½å¤Ÿé€šè¿‡æ·±åº¦æµ‹è¯•ä½†æ˜¯å…³é—­æ·±åº¦å†™å…¥ã€‚éœ€è¦å¤„äºé€æ˜çš„æ¸²æŸ“é˜Ÿåˆ—ï¼š`ZTest Off ` `â€œRenderTypeâ€ = "Transparent"` `"Queue"="Transparent"`
- <img src="D:/TyporaImage/image-20241120173154145-1739258157660-1.png" alt="image-20241120173154145" style="zoom:50%;" />â€”â€”å¯ä»¥å®ç°ç±»ä¼¼åŸç¥çš„å…ƒç´ è§†é‡æ•ˆæœï¼Œå®ƒä¼šå¯¹æ¥è§¦åˆ°çš„ç‰©ä½“è¡¨é¢è®¾å®šå€¼ä¸º1



#### 4ã€ä½¿ç”¨æ·±åº¦åšä¸€ä¸ªæ°´ä½“æ¸²æŸ“

æ°´ä½“æ¸²æŸ“åœ¨ç¬¬äº”ç« çš„æ—¶å€™ä¼šé‡æ–°è¿›è¡ŒçŸ¥è¯†çš„å®Œæ•´å½’çº³ï¼Œæ‰€ä»¥è¿™é‡Œåªæ˜¯å…ˆè¿›è¡Œç®€å•çš„æ¨¡æ‹Ÿæ·±åº¦ã€‚

![image-20250211150640465](D:/TyporaImage/image-20250211150640465.png)

![image-20250211150742380](D:/TyporaImage/image-20250211150742380.png)

- å®ç°æ­¥éª¤ï¼š
  - å› ä¸ºé‡å»ºä¸–ç•Œåæ ‡éœ€è¦æ·±åº¦ï¼Œä¸èƒŒæ™¯è¿›è¡Œå¯¹æ¯”ï¼Œå› æ­¤è¦æ±‚å…³é—­æ·±åº¦å†™å…¥ï¼Œå¹¶ä¸”å¼€å¯ä¸é€æ˜åº¦åºåˆ—ï¼Œä»¥åŠä¸é€æ˜çš„æ¸²æŸ“æ ·å¼ï¼š`ZTest Off ` `â€œRenderTypeâ€ = "Transparent"` `"Queue"="Transparent"`
  - ![image-20250211151122558](D:/TyporaImage/image-20250211151122558.png)![image-20250211151135115](D:/TyporaImage/image-20250211151135115.png)

- å¯ä»¥å°è¯•æ·»åŠ ç„¦æ•£ï¼Œæµ®æ²«ï¼Œæ³¢çº¹ï¼Œåå°„ï¼Œè²æ¶…å°”ç­‰ã€‚
  - å¯¹äºå®Œæ•´çš„å­¦ä¹ æˆ‘ä¼šå‘è¿™ä½å¤§ä½¬ä¸€æ ·[[Unity/URPå­¦ä¹ \]é£æ ¼åŒ–æ°´ä½“æ¸²æŸ“(ä¸€)_unity urpæ°´é¢-CSDNåšå®¢](https://blog.csdn.net/Phantom1516/article/details/128762607)
  - å› ä¸ºä½¿ç”¨åˆ°äº†æ ¹æ®æ·±åº¦é‡å»ºä¸–ç•Œåæ ‡çš„çŸ¥è¯†ç‚¹ï¼Œå¯èƒ½éœ€è¦å‚è€ƒ[ã€unity shader/é£æ ¼åŒ–æ°´è¡¨é¢æ¸²æŸ“/åŸºç¡€ç¬”è®°ã€‘urpä»£ç ç‰ˆ01-æ°´é¢ä¸æ°´åº•çš„æ·±åº¦åˆ¤æ–­_urp æ°´æ¸²æŸ“-CSDNåšå®¢](https://blog.csdn.net/qq_43544518/article/details/128747765)
  - ç­‰åé¢å­¦åˆ°æ°´ä½“æ¸²æŸ“çš„æ—¶å€™ä¼šå¯¹è¿™ä¸ªæ ¹æ®æ·±åº¦é‡å»ºä¸–ç•Œåæ ‡é‡æ–°å­¦ä¹ ï¼Œå±Šæ—¶ä¼šå›é¡¾shaderå…¥é—¨ç²¾è¦



### 3.3 æ›²é¢ç»†åˆ†ä¸å‡ ä½•ç€è‰²å™¨ å¤§è§„æ¨¡è‰æ¸²æŸ“



#### **æ›²é¢ç»†åˆ†ä»£ç åˆå°è¯•**

å‚è€ƒï¼š[Unityæ¸²æŸ“åŸºç¡€ï¼šURPä¸‹æ›²é¢ç»†åˆ†çš„å®ç° - çŸ¥ä¹ (zhihu.com)](https://zhuanlan.zhihu.com/p/359999755)

![img](D:/TyporaImage/v2-f2533a10993773785a1b1ce226e796c9_1440w.jpg)

**æ•ˆæœ**

- <img src="D:/TyporaImage/image-20250212163051148.png" alt="image-20250212163051148" style="zoom:33%;" />
- ![åŠ¨ç”»](D:/TyporaImage/%E5%8A%A8%E7%94%BB-1739349828608-3.gif)
  - ç›´æ¥ä»Unityæ–°å»ºçš„çƒ
  - ç®€å•çš„æ¼”ç¤ºæ•ˆæœ
  - å¯ä»¥ç»†åˆ†æ›´å¤šçš„ä¸‰è§’é¢
  - ç»†åˆ†ä¹‹åå¯ä»¥æ·»åŠ ç½®æ¢è´´å›¾ï¼Œå¯¹ç‰©ä½“è¿›è¡ŒçœŸå®çš„é¡¶çº¿ä¿®æ”¹
- ![åŠ¨ç”»](D:/TyporaImage/%E5%8A%A8%E7%94%BB-1739350133709-5.gif)
  - é€šè¿‡è°ƒæ•´æ•°å€¼å¯ä»¥å˜åŒ–æ›²é¢ç»†åˆ†çš„æ•°é‡
  - æ”¯æŒåŠ¨æ€è°ƒæ•´ç½®æ¢è´´å›¾çš„å¼ºåº¦

**ä»£ç **

```c#
Shader "Stardy/URP/Text/3.3 Test_Tessellation"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
        [Space(20)]
        [Header(Tessellation)]
        _TessFactor("Tess Factor",Range(1,64)) = 4
        _Displacement("Displacement", Range(0, 1)) = 0.1
    }
    SubShader
    {
        Tags 
        { 
            "RenderType"="Opaque" 
            "RenderPipeline" = "UniversalRenderPipeline"
        }

        HLSLINCLUDE

        //include
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"

        //pragmas
        //æ–°å¢åŠ äº†hullï¼Œdomainå’Œæ ‡æ³¨éœ€è¦tessellation
        #pragma target 4.6     //ä½¿ç”¨ç»†åˆ†æ—¶çš„æœ€ä½ç€è‰²å™¨ç›®æ ‡çº§åˆ«ä¸º4.6ã€‚å¦‚æœæˆ‘ä»¬ä¸æ‰‹åŠ¨è®¾ç½®ï¼ŒUnityå°†å‘å‡ºè­¦å‘Šå¹¶è‡ªåŠ¨ä½¿ç”¨è¯¥çº§åˆ«ã€‚ä½†æˆ‘ä¸€å¼€å§‹ç”¨çš„æ˜¯4.5ä¹Ÿæ²¡æœ‰æŠ¥é”™

        TEXTURE2D(_MainTex);
        SAMPLER(sampler_MainTex);

        CBUFFER_START(UnityPerMaterial)
        uniform float4 _MainTex_ST;
        uniform float _TessFactor;
        uniform float _Displacement;
        CBUFFER_END


        //structs
        struct Attributes
        {
            float4 positionOS : POSITION;
            float2 texcoord   : TEXCOORD0;
            float3 normalOS   : NORMAL;
        };

        struct Varyings
        {
            float4 positionCS : SV_POSITION;
            float3 positionWS : TEXCOORD0;
            float2 uv         : TEXCOORD1;
            float3 normalWS   : TEXCOORD2;
        };

        //---------------new----------------
        //æ–°å¢åŠ äº†Domainå±æ€§
        struct DomainAttributes
        {
            float4 positionOS : TEXCOORD0;
            float2 uv         : TEXCOORD1;
            float3 normalOS   : NORMAL;
        };

        //---------------new----------------
        struct TessControlPoint //è¿™ä¸ªç»“æ„ä½“ä½œä¸ºHull Shaderçš„è¾“å…¥/è¾“å‡ºæ§åˆ¶ç‚¹
        {
            float4 positionOS : INTERNALTESSPOS;    //æ›²é¢ç»†åˆ†ä¸“ç”¨è¯­ä¹‰ï¼Œæ ‡è®°è¿™ä¸ªä½ç½®æ•°æ®å°†å‚ä¸ç»†åˆ†è®¡ç®—
            float2 uv         : TEXCOORD0;
            float3 normalOS   : NORMAL;
            // float4 color : COLOR;
        };


        //---------------new----------------
        struct TessFactors  //ç»†åˆ†å› å­
        {
            float edge[3] : SV_TessFactor;  //ä¸‰ä¸ªç»†åˆ†å› å­
            float inside  : SV_InsideTessFactor;    //ç¬¬å››ä¸ªç»†åˆ†å› å­
        };         

        //---------------new----------------
        // é¡¶ç‚¹ç€è‰²å™¨ï¼Œæ­¤æ—¶åªæ˜¯å°†Attributesé‡Œçš„æ•°æ®é€’äº¤ç»™æ›²é¢ç»†åˆ†é˜¶æ®µ
        TessControlPoint vert_Tess(Attributes IN)
        {
            TessControlPoint OUT;
            OUT.positionOS = IN.positionOS;
            OUT.uv = IN.texcoord;
            OUT.normalOS = IN.normalOS;
            return OUT;
        }


        //---------------new----------------
        //ä¸»è¦çš„å£³ç€è‰²å™¨ï¼Œå¯ä»¥å¤„ç†ä¸‰è§’å½¢ï¼Œå››è¾¹å½¢æˆ–ç­‰å€¼çº¿ã€‚æˆ‘ä»¬å¿…é¡»å‘Šè¯‰å®ƒå¿…é¡»ä½¿ç”¨ä»€ä¹ˆè¡¨é¢å¹¶æä¾›å¿…è¦çš„æ•°æ®ã€‚è¿™æ˜¯ hull ç¨‹åºçš„å·¥ä½œã€‚
        [domain("tri")]
        [outputcontrolpoints(3)]
        [patchconstantfunc("patchConstantFunc")]
        [outputtopology("triangle_cw")]
        [partitioning("integer")]
        TessControlPoint hull_Tess(
            InputPatch<TessControlPoint, 3> patch,  //å‘Hull ç¨‹åºä¼ é€’æ›²é¢è¡¥ä¸çš„å‚æ•°
            uint id : SV_OutputControlPointID)
        {
            return patch[id];
        }

        //---------------new----------------
        TessFactors patchConstantFunc(InputPatch<TessControlPoint, 3> patch)    //å†³å®šäº†Patchçš„å±æ€§æ˜¯å¦‚ä½•è¢«ç»†åˆ†çš„ï¼Œæ¯ä¸ªPatchè°ƒç”¨ä¸€æ¬¡
        {
            TessFactors OUT;

            OUT.edge[0] = OUT.edge[1] = OUT.edge[2] = _TessFactor;
            OUT.inside = _TessFactor;

            return OUT;
        }

        //---------------new----------------
        //è®©domainä¼ ç»™å‡ ä½•ç¨‹åºä¸æ’å€¼å™¨çš„æ•°æ®ä»ç„¶æ˜¯Varyingsç»“æ„ä½“
        //ä½†æ˜¯å¾—å†™åœ¨domain_Tesså‰é¢ï¼Œä¸ç„¶ä¼šæŠ¥é”™
        Varyings vert_AfterTess(DomainAttributes IN)
        {
            Varyings OUT;

            OUT.positionWS = TransformObjectToWorld(IN.positionOS);
            OUT.positionCS = TransformWorldToHClip(OUT.positionWS);
            OUT.uv = IN.uv;
            OUT.normalWS = TransformObjectToWorldNormal(IN.normalOS);

            return OUT;
        }

        //---------------new----------------
        [domain("tri")]
        Varyings domain_Tess(
            TessFactors factors,    //ç”±patchConstantFuncå‡½æ•°ç”Ÿæˆçš„ç»†åˆ†å› å­
            OutputPatch<TessControlPoint, 3> patch,     //Hullç€è‰²å™¨ä¼ å…¥çš„patchæ•°æ®ã€‚ç¬¬äºŒä¸ªå‚æ•°éœ€è¦å’ŒInputPatchç¬¬äºŒä¸ªå‚æ•°å¯¹åº”
            float3 barycentricCoordinates : SV_DomainLocation)  //ç”±æ›²é¢ç»†åˆ†é˜¶æ®µé˜¶æ®µä¼ å…¥çš„é¡¶ç‚¹ä½ç½®ä¿¡æ¯
        {
            DomainAttributes OUT;
            //åˆå§‹åŒ–OUT
            OUT = (DomainAttributes)0;

            //æ ¹æ®é‡å¿ƒåæ ‡æ’å…¥æ³•çº¿æ•°æ®
            float3 normalOS = patch[0].normalOS * barycentricCoordinates.x + 
                              patch[1].normalOS * barycentricCoordinates.y + 
                              patch[2].normalOS * barycentricCoordinates.z;


            //æ ¹æ®é‡å¿ƒåæ ‡è¿›è¡Œä½ç½®å’ŒUVçš„æ’å€¼
            float4 positionOS = patch[0].positionOS * barycentricCoordinates.x + 
                                patch[1].positionOS * barycentricCoordinates.y + 
                                patch[2].positionOS * barycentricCoordinates.z;

            float2 uv = patch[0].uv * barycentricCoordinates.x + 
                        patch[1].uv * barycentricCoordinates.y + 
                        patch[2].uv * barycentricCoordinates.z;

             //ç½®æ¢è´´å›¾æ›¿æ¢
             float displacement = SAMPLE_TEXTURE2D_LOD(_MainTex, sampler_MainTex, uv, 0).r * _Displacement;


             positionOS.xyz += displacement * normalOS;

             OUT.positionOS = positionOS;
             OUT.uv = uv;
             OUT.normalOS = normalOS;


            return vert_AfterTess(OUT);
        }

        float4 frag_Tess(Varyings IN) : SV_Target
        {
            // ç®€å•æ˜¾ç¤ºæ³•çº¿æ–¹å‘
            return float4(IN.normalWS * 0.5 + 0.5, 1.0);
        }

        
        ENDHLSL
        
        Pass
        {
            Name "TESSPass"
            Tags 
            {
                "LightMode" = "UniversalForward"
            }
            HLSLPROGRAM

            #pragma vertex vert_Tess
            #pragma fragment frag_Tess
            #pragma hull hull_Tess    // å£°æ˜hull shader
            #pragma domain domain_Tess  // å£°æ˜domain shader

            ENDHLSL
        }
    }
}

```



##### **ä»£ç è§£æ**

###### 	**1. `#pragma target 4.6`**

ä½¿ç”¨ç»†åˆ†æ—¶çš„æœ€ä½ç€è‰²å™¨ç›®æ ‡çº§åˆ«ä¸º4.6ã€‚å¦‚æœæˆ‘ä»¬ä¸æ‰‹åŠ¨è®¾ç½®ï¼ŒUnityå°†å‘å‡ºè­¦å‘Šå¹¶è‡ªåŠ¨ä½¿ç”¨è¯¥çº§åˆ«



###### 	**2. `#pragma`çš„å£°æ˜è¦å¤šä¸¤ä¸ªé˜¶æ®µ**

`#pragma hull hull_Tess`    å’Œ   `#pragma domain domain_Tess` ,æ¥ä¸‹æ¥ä¼šå¯¹è¿™ä¸¤ä¸ªé˜¶æ®µè¿›è¡Œå®Œå–„



###### 	**3. é¡¶ç‚¹ç»†åˆ†ç€è‰²å™¨**

```C
TessControlPoint vert_Tess(Attributes IN)
        {
            TessControlPoint OUT;
            OUT.positionOS = IN.positionOS;
            OUT.uv = IN.texcoord;
            OUT.normalOS = IN.normalOS;
            return OUT;
        }
```

- å°†åŸå§‹é¡¶ç‚¹çš„ä½ç½®ï¼Œçº¹ç†åæ ‡å’Œæ³•çº¿ç­‰éœ€è¦çš„æ•°æ®è¿›è¡Œç®€å•çš„ä¼ é€’ç»™`TessControlPoint`ã€‚

- ä¸å†åƒä»¥å‰é‚£æ ·è´Ÿè´£æŠŠé¡¶ç‚¹åæ ‡ä»ObjectSpaceè½¬æ¢åˆ°ClipSpaceï¼Œæˆ–æ˜¯è´´å›¾UVè½¬æ¢ç­‰å·¥ä½œï¼Œæ­¤å¤„åªæ˜¯ç®€å•åœ°å°†`Attributes`ä¸­çš„æ•°æ®ä¼ é€’ç»™æ›²é¢ç»†åˆ†é˜¶æ®µçš„`ControlPoint`ã€‚

- `ControlPoint`çš„ç»“æ„ä½“å¦‚ä¸‹ï¼š

  - ```c
    struct TessControlPoint //è¿™ä¸ªç»“æ„ä½“ä½œä¸ºHull Shaderçš„è¾“å…¥/è¾“å‡ºæ§åˆ¶ç‚¹
    {
                float4 positionOS : INTERNALTESSPOS;    //æ›²é¢ç»†åˆ†ä¸“ç”¨è¯­ä¹‰ï¼Œæ ‡è®°è¿™ä¸ªä½ç½®æ•°æ®å°†å‚ä¸ç»†åˆ†è®¡ç®—
                float2 uv         : TEXCOORD0;
                float3 normalOS   : NORMAL;
                // float4 color : COLOR;
    };
    ```

    - å¯¹äºç‰©ä½“ç©ºé—´ä½ç½®ä¿¡æ¯ï¼Œéœ€è¦ç”¨ä¸“ç”¨çš„è¯­ä¹‰`INTERNALTESSPOS`æ³¨æ˜

- `Attribute`çš„ç»“æ„ä½“å¦‚ä¸‹ï¼š

  - ```C
    //structs
            struct Attributes
            {
                float4 positionOS : POSITION;
                float2 texcoord   : TEXCOORD0;
                float3 normalOS   : NORMAL;
            };
    ```

    - **åœ¨`Varyings`ç»“æ„ä½“é‡Œé¢**ï¼Œå¯¹äºè£åˆ‡ç©ºé—´çš„`positionCS`ï¼Œä¼šä½¿ç”¨`SV_POSITION`è¯­ä¹‰è¿›è¡Œç‰¹åˆ«æ³¨æ˜ï¼š`float4 positionCS  : SV_POSITION;`

  - å¯¹æ¯”å¯è§ï¼Œä¸¤è€…ç»“æ„ä½“å‡ ä¹ç›¸åŒï¼Œåªæ˜¯`ControlPoint`ä¸­çš„`vertex`ä½¿ç”¨`INTERNALTESSPOS`ä»£æ›¿`POSITION`è¯­æ„ï¼Œå¦åˆ™ç¼–è¯‘å™¨ä¼šæŠ¥ä½ç½®è¯­ä¹‰çš„é‡ç”¨

  

###### 	        **4. Hullç€è‰²å™¨**

- ç»†åˆ†é˜¶æ®µï¼Œç¡®å®šå¦‚ä½•ç»†åˆ†è¡¥ä¸

```c
        //ä¸»è¦çš„å£³ç€è‰²å™¨ï¼Œå¯ä»¥å¤„ç†ä¸‰è§’å½¢ï¼Œå››è¾¹å½¢æˆ–ç­‰å€¼çº¿ã€‚æˆ‘ä»¬å¿…é¡»å‘Šè¯‰å®ƒå¿…é¡»ä½¿ç”¨ä»€ä¹ˆè¡¨é¢å¹¶æä¾›å¿…è¦çš„æ•°æ®ã€‚è¿™æ˜¯ hull ç¨‹åºçš„å·¥ä½œã€‚
		//ä»…ä»…å‡½æ•°å£°æ˜æ˜¯ä¸è¡Œçš„ï¼Œç¼–è¯‘å™¨ä¼šæŠ¥é”™ï¼Œè¦æ±‚æˆ‘ä»¬æŒ‡å®šè¯¦ç»†çš„å‚æ•°ï¼Œ
        [domain("tri")]
        [outputcontrolpoints(3)]    
        [patchconstantfunc("patchConstantFunc")]   //è¡¥ä¸å¸¸é‡å‡½æ•°ï¼Œä¸Hullå¹¶è¡Œè¿è¡Œçš„å­é˜¶æ®µ 
        [outputtopology("triangle_cw")]
        [partitioning("integer")]   
        TessControlPoint hull_Tess(
            InputPatch<TessControlPoint, 3> patch,  //å‘Hull ç¨‹åºä¼ é€’æ›²é¢è¡¥ä¸çš„å‚æ•°
            uint id : SV_OutputControlPointID)
        {
            return patch[id];
        }
```

- `[domain("tri")] `ï¼šæŒ‡å®špatchçš„ç±»å‹ï¼Œå¯é€‰çš„æœ‰ï¼š`tri`(ä¸‰è§’å½¢)ã€`quad`ï¼ˆå››è¾¹å½¢ï¼‰ã€`isoline`(çº¿æ®µ)
- `[outputcontrolpoints(3)]`ï¼šæŒ‡å®šè¾“å‡ºçš„æ§åˆ¶ç‚¹çš„æ•°é‡ï¼ˆæ¯ä¸ªå›¾å…ƒï¼‰ï¼Œä¸ä¸€å®šä¸è¾“å…¥æ•°é‡ç›¸åŒï¼Œä¹Ÿå¯ä»¥æ–°å¢æ§åˆ¶ç‚¹ã€‚æ­¤å¤„è®¾ç½®ä¸º3ï¼Œæ˜¯æ˜ç¡®åœ°å‘Šè¯‰ç¼–è¯‘å™¨æ¯ä¸ªè¡¥ä¸è¾“å‡ºä¸‰ä¸ªæ§åˆ¶ç‚¹
- `[patchconstantfunc("patchConstantFunc")] `ï¼šæŒ‡å®šè¡¥ä¸å¸¸æ•°å‡½æ•°ã€‚GPUå¿…é¡»çŸ¥é“åº”å°†è¡¥ä¸åˆ‡æˆå¤šå°‘éƒ¨åˆ†ã€‚è¿™ä¸æ˜¯ä¸€ä¸ªæ’å®šå€¼ï¼Œæ¯ä¸ªè¡¥ä¸å¯èƒ½æœ‰æ‰€ä¸åŒã€‚å¿…é¡»æä¾›ä¸€ä¸ªè¯„ä¼°æ­¤å€¼çš„å‡½æ•°ï¼Œç§°ä¸ºè¡¥ä¸å¸¸æ•°å‡½æ•°ï¼ˆPatch Constant Functionsï¼‰ï¼Œä¸Hullå¹¶è¡Œè¿è¡Œçš„å­é˜¶æ®µ
- `[outputtopology("triangle_cw")] `ï¼š è¾“å‡ºæ‹“æ‰‘ç»“æ„ã€‚å½“GPUåˆ›å»ºæ–°ä¸‰è§’å½¢æ—¶ï¼Œå®ƒéœ€è¦çŸ¥é“æˆ‘ä»¬æ˜¯å¦è¦æŒ‰é¡ºæ—¶é’ˆæˆ–é€†æ—¶é’ˆå®šä¹‰å®ƒä»¬ã€‚æœ‰ä¸‰ç§ï¼š`triangle_cw`ï¼ˆé¡ºæ—¶é’ˆç¯ç»•ä¸‰è§’å½¢ï¼‰ã€`triangle_ccw`ï¼ˆé€†æ—¶é’ˆç¯ç»•ä¸‰è§’å½¢ï¼‰ã€`line`ï¼ˆçº¿æ®µï¼‰ã€‚
- `[partitioning("integer")]`ï¼šåˆ†å‰²æ¨¡å¼ï¼Œèµ·åˆ°å‘ŠçŸ¥GPUåº”è¯¥å¦‚ä½•åˆ†å‰²è¡¥ä¸çš„ä½œç”¨å‘¢ï¼Œå…±æœ‰ä¸‰ç§ï¼š`integer`ï¼ˆç¡¬åˆ†å‰²ï¼‰ï¼Œ`fractional_even`ï¼ˆè½¯æ¸å˜åˆ†å‰²ï¼‰ï¼Œ`fractional_odd`ï¼ˆè½¯æ¸å˜åˆ†å‰²ï¼‰ã€‚`TessControlPoint hull_Tess(InputPatch<TessControlPoint, 3> patch,uint id : SV_OutputControlPointID)`:InputPatchå‚æ•°æ˜¯å‘Hull ç¨‹åºä¼ é€’æ›²é¢è¡¥ä¸çš„å‚æ•°ã€‚Patchæ˜¯ç½‘æ ¼é¡¶ç‚¹çš„é›†åˆã€‚å¿…é¡»æŒ‡å®šé¡¶ç‚¹çš„æ•°æ®æ ¼å¼ã€‚
  - åœ¨å¤„ç†ä¸‰è§’å½¢æ—¶ï¼Œæ¯ä¸ªè¡¥ä¸å°†åŒ…å«ä¸‰ä¸ªé¡¶ç‚¹ï¼Œæ­¤æ•°é‡å¿…é¡»æŒ‡å®šä¸º`InputPatch`çš„ç¬¬äºŒä¸ªæ¨¡æ¿å‚æ•°ï¼Œæ‰€ä»¥ç¬¬äºŒä¸ªå‚æ•°è®¾ç½®ä¸º3ã€‚
  - Hullç¨‹åºçš„å·¥ä½œæ˜¯å°†æ‰€éœ€çš„é¡¶ç‚¹æ•°æ®ä¼ é€’åˆ°ç»†åˆ†é˜¶æ®µã€‚å°½ç®¡å‘å…¶æä¾›äº†æ•´ä¸ªè¡¥ä¸ï¼Œä½†è¯¥å‡½æ•°ä¸€æ¬¡ä»…åº”è¾“å‡ºä¸€ä¸ªé¡¶ç‚¹ã€‚è¡¥ä¸ä¸­çš„æ¯ä¸ªé¡¶ç‚¹éƒ½ä¼šè°ƒç”¨ä¸€æ¬¡å®ƒï¼Œå¹¶å¸¦æœ‰ä¸€ä¸ªé™„åŠ å‚æ•°ï¼Œè¯¥å‚æ•°æŒ‡å®šåº”è¯¥ä½¿ç”¨å“ªä¸ªæ§åˆ¶ç‚¹ï¼ˆé¡¶ç‚¹ï¼‰ã€‚è¯¥å‚æ•°æ˜¯å…·æœ‰`SV_OutputControlPointID`è¯­ä¹‰çš„æ— ç¬¦å·æ•´æ•°ã€‚



###### 	**5. è¡¥ä¸å¸¸æ•°å‡½æ•°ï¼ˆPatch Constant Functionï¼‰**

```C
        TessFactors patchConstantFunc(InputPatch<TessControlPoint, 3> patch)
        {
            TessFactors OUT;
            OUT.edge[0] = OUT.edge[1] = OUT.edge[2] = _TessFactor;
            OUT.inside = _TessFactor;
            return OUT;
        }
```

- å†³å®šPatchçš„å±æ€§æ˜¯å¦‚ä½•ç»†åˆ†çš„ã€‚
  - è¿™æ„å‘³ç€å®ƒæ¯ä¸ªPatchä»…è¢«è°ƒç”¨ä¸€æ¬¡ï¼Œè€Œä¸æ˜¯æ¯ä¸ªæ§åˆ¶ç‚¹è¢«è°ƒç”¨ä¸€æ¬¡ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆå®ƒè¢«ç§°ä¸ºå¸¸é‡å‡½æ•°ï¼Œåœ¨æ•´ä¸ªPatchä¸­éƒ½æ˜¯å¸¸é‡çš„åŸå› ã€‚
  - è¿™é‡Œçš„`InputPatch`æ˜¯è¾“å…¥
- `edge[3]`ï¼šæ§åˆ¶ä¸‰è§’å½¢æ¯æ¡è¾¹çš„ç»†åˆ†å› å­
- `inside`ï¼šæ§åˆ¶å†…éƒ¨åŒºåŸŸçš„ç»†åˆ†å¯†åº¦
- **è¿™æ˜¯å†³å®šæ›²é¢ç»†åˆ†ç¨‹åº¦çš„==æ ¸å¿ƒæ§åˆ¶ç‚¹==**

**è¾“å‡ºçš„ç»“æ„ä½“ï¼š**

```C
struct TessFactors	//ç»†åˆ†å› å­
        {
            float edge[3] : SV_TessFactor;	//ä¸‰ä¸ªç»†åˆ†å› å­
            float inside  : SV_InsideTessFactor;	//ç¬¬å››ä¸ªç»†åˆ†å› å­
        };      
```

- ä¸ºäº†**ç¡®å®šå¦‚ä½•ç»†åˆ†ä¸‰è§’å½¢**ï¼ŒGPUä½¿ç”¨äº†å››ä¸ªç»†åˆ†å› å­ã€‚ä¸‰è§’å½¢é¢ç‰‡çš„æ¯ä¸ªè¾¹ç¼˜éƒ½æœ‰ä¸€ä¸ªå› æ•°ã€‚ä¸‰è§’å½¢çš„å†…éƒ¨ä¹Ÿæœ‰ä¸€ä¸ªå› ç´ ã€‚ä¸‰ä¸ªè¾¹ç¼˜å‘é‡å¿…é¡»ä½œä¸ºå…·æœ‰`SV_TessFactor`è¯­ä¹‰çš„floatæ•°ç»„ä¼ é€’ã€‚å†…éƒ¨å› ç´ ä½¿ç”¨`SV_InsideTessFactor`è¯­ä¹‰
  - å®é™…ä¸Šï¼Œæ­¤åŠŸèƒ½æ˜¯ä¸HullProgramå¹¶è¡Œè¿è¡Œçš„å­é˜¶æ®µã€‚<img src="D:/TyporaImage/v2-d4a32cb71db01807810331a66dfd53eb_1440w.jpg" alt="img" style="zoom: 50%;" />



######          **6. Domainç€è‰²å™¨**

- **å·²çŸ¥å¦‚ä½•ç»†åˆ†è¡¥ä¸ï¼Œè¯„ä¼°ç»“æœå¹¶ç”Ÿæˆæœ€ç»ˆä¸‰è§’å½¢çš„é¡¶ç‚¹ã€‚**

```c
Varyings vert_AfterTess(DomainAttributes IN)
{
            Varyings OUT;
            OUT.positionWS = TransformObjectToWorld(IN.positionOS);
            OUT.positionCS = TransformWorldToHClip(OUT.positionWS);
            OUT.uv = IN.uv;
            OUT.normalWS = TransformObjectToWorldNormal(IN.normalOS);
            return OUT;
}

[domain("tri")]
DomainAttributes domain_Tess(
            TessFactors factors,
            OutputPatch<TessControlPoint, 3> patch,
            float3 barycentricCoordinates : SV_DomainLocation)
{
            DomainAttributes OUT;
            OUT = (DomainAttributes)0;
            //æ ¹æ®é‡å¿ƒåæ ‡æ’å…¥æ³•çº¿æ•°æ®
float3 normalOS = patch[0].normalOS * barycentricCoordinates.x + 
                  patch[1].normalOS * barycentricCoordinates.y + 
                  patch[2].normalOS * barycentricCoordinates.z;
            //æ ¹æ®é‡å¿ƒåæ ‡è¿›è¡Œä½ç½®å’ŒUVçš„æ’å€¼
float4 positionOS = patch[0].positionOS * barycentricCoordinates.x + 
                    patch[1].positionOS * barycentricCoordinates.y + 
                    patch[2].positionOS * barycentricCoordinates.z;
float2 uv = patch[0].uv * barycentricCoordinates.x + 
            patch[1].uv * barycentricCoordinates.y + 
            patch[2].uv * barycentricCoordinates.z;
             //ç½®æ¢è´´å›¾æ›¿æ¢
             float displacement = SAMPLE_TEXTURE2D_LOD(_MainTex, sampler_MainTex, uv, 0).r * _Displacement;
             positionOS.xyz += displacement * normalOS;
             OUT.positionWS = TransformObjectToWorld(positionOS.xyz);
             OUT.positionCS = TransformWorldToHClip(OUT.positionWS);
             OUT.uv = uv;
             OUT.normalWS = TransformObjectToWorldNormal(normalOS);
            return OUT;
}
```

- æ¯ä¸ªé¡¶ç‚¹éƒ½ä¼šè°ƒç”¨ä¸€æ¬¡Domainç€è‰²å™¨ã€‚
  - è®¡ç®—é‡å¾ˆå¤§ï¼Œè€Œä¸”æ‰€æœ‰çš„é¡¶ç‚¹ä¿¡æ¯éƒ½ä¼šåœ¨è¿™é‡Œé‡æ–°è®¡ç®—ï¼Œæœ€åå°†é¡¶ç‚¹åæ ‡è½¬æ¢åˆ°æŠ•å½±ç©ºé—´ã€‚
- **è§£æ**
  - `OutputPatch`ï¼Œæ˜¯è¾“å‡ºè¡¥ä¸ï¼Œå³ç”Ÿæˆè¡¥ä¸ã€‚
  - `[domain("tri")]`ï¼šHullç€è‰²å™¨å’ŒDomainç€è‰²å™¨éƒ½ä½œç”¨äºç›¸åŒçš„åŸŸï¼Œå³ä¸‰è§’å½¢ã€‚é€šè¿‡domainå±æ€§å†æ¬¡å‘å‡ºä¿¡å·
  - `TessFactors factors`ï¼š**ç”±`patchConstantFunc`è¡¥ä¸å¸¸æ•°å‡½æ•°è¾“å…¥**ï¼Œç»†åˆ†å‚æ•°
  - `OutputPatch<TessControlPoint, 3> patch`ï¼šç”±Hullç€è‰²å™¨ä¼ å…¥Patchæ•°æ®ï¼Œ**å°–æ‹¬å·çš„ç¬¬äºŒä¸ªå‚æ•°ä¸Hullç€è‰²å™¨ä¸­çš„`InputPatch`å¯¹åº”**ã€‚
  - `SV_DomainLocation`ï¼šç”±æ›²é¢ç»†åˆ†é˜¶æ®µé˜¶æ®µä¼ å…¥çš„é¡¶ç‚¹ä½ç½®ä¿¡æ¯ã€‚
- **è¯´æ˜**
  - Hullåªæ˜¯ç¡®å®šè¡¥ä¸çš„ç»†åˆ†æ–¹å¼ï¼Œä¸ä¼šäº§ç”Ÿä»»ä½•æ–°çš„é¡¶ç‚¹ã€‚
    - ä½†æ˜¯**å®ƒä¼šä¸ºè¿™äº›é¡¶ç‚¹æä¾›é‡å¿ƒåæ ‡ã€‚**
      - `[domain("tri")]`æä¾›é‡å¿ƒåæ ‡ï¼Œç”¨äºä¸‰è§’å½¢ç»†åˆ†
      - `[domain("quad")]`æä¾›UVåæ ‡[0,1]ï¼Œç”¨äºå››è¾¹å½¢ç»†åˆ†
      - `[domain("isoline")]`æä¾›UVåæ ‡ï¼Œç”¨äºæ›²çº¿ç»†åˆ†
    - ä½¿ç”¨è¿™äº›åæ ‡æ¥å¯¼å‡ºæœ€ç»ˆé¡¶ç‚¹ï¼Œå–å†³äºDomainç€è‰²å™¨ã€‚ä¸ºäº†ä½¿ä¹‹æˆä¸ºå¯èƒ½ï¼Œ**æ¯ä¸ªé¡¶ç‚¹éƒ½ä¼šè°ƒç”¨ä¸€æ¬¡åŸŸå‡½æ•°ï¼Œå¹¶ä¸ºå…¶æä¾›é‡å¿ƒåæ ‡ã€‚**
  - **ç»è¿‡äº†Domainä¹‹åï¼Œå°±æœ‰äº†æ–°çš„é¡¶ç‚¹**ï¼Œä¹‹åè¿™äº›æ–°ç”Ÿæˆçš„é¡¶ç‚¹ä¼šè¢«å‘é€åˆ°å‡ ä½•ç€è‰²å™¨æˆ–è€…æ˜¯å…‰æ …åŒ–æ’å€¼å™¨ã€‚ä½†æˆ‘ä»¬ä¸åº”è¯¥è®©å®ƒæ¥æ›¿ä»£é¡¶ç‚¹ç€è‰²å™¨ï¼Œå› ä¸º**æ­¤é˜¶æ®µä¹‹åçš„å‡ ä½•ç¨‹åºæˆ–æ’å€¼å™¨éœ€è¦Varyingsæ•°æ®ï¼Œè€Œä¸æ˜¯Attributesã€‚**
    - å› æ­¤æˆ‘ä»¬çš„è§£å†³åŠæ³•æ˜¯ï¼Œè®©Domainç€è‰²å™¨æ¥ç®¡åŸå§‹é¡¶ç‚¹çš„ç¨‹åºçš„æŒ‡è´£ã€‚
      - å³ï¼Œç»“å°¾è°ƒç”¨æ–°å†™çš„é¡¶ç‚¹ç€è‰²å™¨`AfterTessVertProgram`ã€‚



##### æ€»ç»“

- **ä¸‰ä¸ªç»“æ„ä½“**
  - `TessControlPoint`ç»™Hull Shaderè¾“å…¥è¾“å‡ºï¼Œä»¥åŠä½œä¸ºpatchçš„å‚æ•°
  - `TessFactors`å®šä¹‰ç»†åˆ†å› å­åœ¨è¡¥ä¸å¸¸æ•°å‡½æ•°è¢«ç”¨æ¥å®šä¹‰ç»†åˆ†æ–¹å¼
  - `DomainAttributes`ç”¨æ¥Domain ShaderçœŸæ­£çš„ç”Ÿæˆé¡¶ç‚¹ï¼Œå¹¶ä¸”ä¼ å›ç»™é¡¶ç‚¹ç€è‰²å™¨
    - ä¹Ÿå¯ä»¥è‡ªè¡Œè°ƒç”¨é¡¶ç‚¹ç€è‰²å™¨ï¼Œä¿è¯ä¼ å‡ºæ¥çš„æ˜¯`Varyings`
- **ä¸€ä¸ªå‡½æ•°**
  - `patchConstantFunc`å¯¹é¡¶ç‚¹çš„å¦‚ä½•ç»†åˆ†ï¼Œå¯¹ç»“æ„ä½“`TessFactors`æ“ä½œ
    - éœ€ä¼ å…¥`InputPatch`ï¼Œå¹¶ä¸”æŒ‡å®šè¾“å‡ºå®šç‚¹æ•°ï¼š`(InputPatch<TessControlPoint, 3> patch)`
- **ä¸¤ä¸ªshader**
  - `TessControlPoint hull`ï¼šå®šä¹‰ç»†åˆ†çš„æ–¹å¼ï¼Œä½†æ˜¯ä¸è¿›è¡Œç»†åˆ†ã€‚
    - **ä¼ å…¥**
      - è¡¥ä¸çš„å‚æ•°`InputPatch<TessControlPoint, 3> patch`ï¼Œ
      - æ–°ç”Ÿæˆçš„æ§åˆ¶ç‚¹çš„IDï¼š`uint id : SV_OutputControlPointID`
    - éœ€è¦å¾ˆå¤š**å‰ç½®è®¾ç½®**
      - `[domain("tri")]`ï¼šæŒ‡å®špatchç±»å‹
      - `[outputcontrolpoints(3)] `ï¼šæŒ‡å®šæ¯ä¸ªå›¾å…ƒè¾“å‡ºçš„æ§åˆ¶ç‚¹çš„æ•°é‡ã€‚
      - `[patchconstantfunc("patchConstantFunc")]`ï¼šæŒ‡å®šé¢ç‰‡å¸¸æ•°å‡½æ•°ã€‚
      - `[outputtopology("triangle_cw")]`ï¼šæŒ‡å®šè¾“å‡ºæ‹“æ‰‘ç»“æ„ã€‚
      - `[partitioning("integer")]`ï¼šæŒ‡å®šåˆ†å‰²æ¨¡å¼ã€‚
  - `domain`ï¼šæŒ‰ç…§Hull Shaderæä¾›çš„è§„åˆ™ï¼Œç”Ÿæˆé¡¶ç‚¹ã€‚
    - **ä¼ å…¥**
      - `TessFactors factors`ï¼šç”±`patchConstantFunc`å‡½æ•°æŒ‡å®šçš„ç»†åˆ†å› å­
      - `OutputPatch<TessControlPoint, 3> patch`ï¼šHullä¼ è¿‡æ¥çš„patchæ•°æ®ï¼Œç¬¬äºŒä¸ªå‚æ•°éœ€è¦å’Œ`InputPatch`ç›¸å¯¹åº”ã€‚
      - `float3 barycentricCoordinates : SV_DomainLocation`ï¼šä¸‰è§’å½¢ç±»å‹çš„`SV_DomainLocation`è¿˜ä¼šå¸¦æœ‰é‡å¿ƒåæ ‡
    - **å‰ç½®è®¾ç½®**
      - `[domain("tri")]`ï¼šæŒ‡å®špatchç±»å‹





#### **å‡ ä½•ç€è‰²å™¨ä»£ç åˆå°è¯•**

â€‹	**ç”¨å‡ ä½•ç€è‰²å™¨ç¨å¾®ç§»åŠ¨ä¸€ä¸‹ç‰©ä½“ï¼Œè¾¾åˆ°ä¸€ç§ä¸æ”¹å˜ç½‘æ ¼è€Œç§»åŠ¨ç½‘æ ¼é¡¶ç‚¹çš„æ•ˆæœ**



**å‰ç½®çŸ¥è¯†**

![img](D:/TyporaImage/v2-4a762aa411bad55ebe504c2ac5494dba_1440w.jpg)

â€‹	**å‡ ä½•ç€è‰²å™¨é˜¶æ®µï¼ˆGeometry Shaderï¼‰**ä½äºé¡¶ç‚¹å’Œç‰‡æ®µé˜¶æ®µä¹‹é—´ã€‚GSä¼šè°ƒç”¨å•ä¸ªå›¾å…ƒä½œä¸ºè¾“å…¥ï¼Œå¹¶å¯èƒ½ä¼šè¾“å‡ºå¤šä¸ªï¼Œä¹Ÿå¯èƒ½ä¸è¾“å‡ºå›¾å…ƒã€‚

â€‹	åº”ç”¨ï¼šè¾“å…¥é¡¶ç‚¹ï¼Œç„¶åå¯¹è¿™äº›é¡¶ç‚¹åšå¤„ç†ã€‚å¯ä»¥åˆ é™¤ï¼Œç§»åŠ¨æˆ–ç”Ÿæˆé¡¶ç‚¹ã€‚

- å¯ä»¥æŒ‰ç…§æŸç§è§„å¾‹ç”Ÿæˆé¡¶ç‚¹ï¼Œæ¯”å¦‚æ‹¿æ¥åš**è‰**



**æ•ˆæœ**

![åŠ¨ç”»](D:/TyporaImage/%E5%8A%A8%E7%94%BB-1739371127805-11.gif)



**ä»£ç **

```c
Shader "Stardy/URP/Text/3.3 Test_GES"
{
    Properties
    {
        _Color ("Color", Color) = (1,1,1,1)
        _NormalControl ("Normal Control", float) = 0.5
    }
    SubShader
    {

        Tags 
        { 
            "RenderType"="Opaque" 
            "RenderPipeline" = "UniversalRenderPipeline"
        }
        
        HLSLINCLUDE

        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"


        struct Attributes
        {
            float4 positionOS : POSITION;
            float3 normalOS   : NORMAL;
        };

        struct Varyings
        {
            float4 positionOS : SV_POSITION;
            float3 normalOS   : NORMAL;
        };

        //-------------new code-------------
        struct GeometryOutput
        {
            float4 positionCS : SV_POSITION;
            float3 normalOS   : TEXCOORD0;
        };



        CBUFFER_START(UnityPerMaterial)
        uniform float4 _Color;
        uniform float _NormalControl;
        CBUFFER_END

        Varyings vert_Common (Attributes IN)
        {
            Varyings OUT;

            OUT.positionOS = IN.positionOS;
            OUT.normalOS = IN.normalOS;

            return OUT;
        }

        //-------------new code-------------
        [maxvertexcount(3)]
        void geom(
            triangle Varyings IN[3],
            inout TriangleStream<GeometryOutput> stream)
        {
            GeometryOutput OUT;

            //é€šè¿‡æ‰©å±•å‡ ä½•åˆ›å»ºæ–°ä¸‰è§’å½¢
            for(int i = 0; i < 3; i++)
            {   
                float4 positionEXT = IN[i].positionOS + float4(IN[i].normalOS * _NormalControl ,1.0);
                OUT.positionCS = TransformObjectToHClip(positionEXT);
                OUT.positionCS += float4(IN[i].normalOS * _NormalControl ,1.0);
                OUT.normalOS = IN[i].normalOS;
                stream.Append(OUT);   //è¿™æ˜¯ä»€ä¹ˆï¼Ÿ
            }
            stream.RestartStrip();//è¿™æ˜¯ä»€ä¹ˆï¼Ÿ
        }

        half4 frag_Common (GeometryOutput IN) : SV_Target
        {
            return _Color * float4(abs(IN.normalOS), 1.0);
        }

        ENDHLSL

        Pass
        {
            Name "GES_Pass"
            Cull Off
            Tags
            {
                "LightMode" = "UniversalForward"
            }
            HLSLPROGRAM
            #pragma vertex vert_Common
            #pragma fragment frag_Common
            #pragma geometry geom

            ENDHLSL
        }
    }
}
```



##### **1. ç›®æ ‡ç€è‰²å™¨ç‰ˆæœ¬**

`#pragma target 4.0 `ä»…å½“ç›®æ ‡ç€è‰²å™¨æ¨¡å‹ä¸º4.0æˆ–æ›´é«˜ç‰ˆæœ¬æ—¶æ‰æ”¯æŒå‡ ä½•ç€è‰²å™¨ã€‚



##### 2. å£°æ˜å‡½æ•°

è‡ªå®šä¹‰å‡½æ•°åï¼Œåªéœ€è¦å£°æ˜äº†ä¹‹åï¼Œç¼–è¯‘è°ƒç”¨(`geometry`)å®ƒå³å¯ã€‚

```C
#pragma geometry geom	//å‡½æ•°çš„è°ƒç”¨

â€¦â€¦
[maxvertexcount(3)]
        void geom(
            triangle Varyings IN[3],
            inout TriangleStream<GeometryOutput> stream)
        {
            GeometryOutput OUT;

            //é€šè¿‡æ‰©å±•å‡ ä½•åˆ›å»ºæ–°ä¸‰è§’å½¢
            for(int i = 0; i < 3; i++)
            {   
                float4 positionEXT = IN[i].positionOS + float4(IN[i].normalOS * _NormalControl ,1.0);
                OUT.positionCS = TransformObjectToHClip(positionEXT);
                OUT.positionCS += float4(IN[i].normalOS * _NormalControl ,1.0);
                OUT.normalOS = IN[i].normalOS;
                stream.Append(OUT); //æ¯ä¸ªAppend()è°ƒç”¨ç”Ÿæˆä¸€ä¸ªæ–°é¡¶ç‚¹
            }
            stream.RestartStrip();
        }
```

- `[maxvertexcount(3)]`ï¼šè¡¨ç¤ºè¾“å‡ºé¡¶ç‚¹æ•°çš„æœ€å¤§å€¼ã€‚å› ä¸ºæˆ‘ä»¬æ­£åœ¨å¤„ç†ä¸‰è§’å½¢ï¼Œæ‰€ä»¥æ¯æ¬¡è°ƒç”¨æ€»æ˜¯è¾“å‡ºä¸‰ä¸ªé¡¶ç‚¹ã€‚

- `triangle Varyings IN[3]`ï¼š`triangle`è¡¨ç¤ºæˆ‘ä»¬æ­£åœ¨å¤„ç†çš„åŸå§‹æ•°æ®ï¼Œåœ¨è¿™é‡Œæ˜¯ä¸‰è§’å½¢ï¼Œå…¶ä»–ç±»å‹è¿˜æœ‰`line`å’Œ`point`ã€‚**å¿…é¡»åœ¨è¾“å…¥ç±»å‹ä¹‹å‰æŒ‡å®šã€‚**

  - ç”±äºä¸‰è§’å½¢æ¯ä¸ªéƒ½æœ‰ä¸‰ä¸ªé¡¶ç‚¹ï¼Œå› æ­¤æˆ‘ä»¬æ­£åœ¨ç ”ç©¶ä¸‰ä¸ªç»“æ„çš„æ•°ç»„ã€‚å¿…é¡»æ˜ç¡®å®šä¹‰å®ƒã€‚

- `inout TriangleStream<GeometryOutput> stream`ï¼šç”±äºå‡ ä½•ç€è‰²å™¨å¯ä»¥è¾“å‡ºçš„é¡¶ç‚¹æ•°é‡å„ä¸ç›¸åŒï¼Œå› æ­¤æˆ‘ä»¬æ²¡æœ‰ç»Ÿä¸€çš„è¿”å›ç±»å‹ã€‚

  - ç›¸åï¼Œ**å‡ ä½•ç€è‰²å™¨å°†å†™å…¥å›¾å…ƒæµ**ã€‚åœ¨ä¾‹å­ä¸­ï¼Œå®ƒæ˜¯ä¸€ä¸ª`TriangleStream`ï¼Œå…¶ä»–çš„ç±»å‹è¿˜æœ‰`PointStream`ã€`LineStream`ï¼Œ**å¿…é¡»å°†å…¶æŒ‡å®šä¸º==inout==å‚æ•°**ã€‚
  - `stream.Append(OUT)`å†™æµã€‚æ¯æ¬¡è°ƒç”¨Appendï¼Œå°±ä¼šæ·»åŠ ä¸€ä¸ªé¡¶ç‚¹åˆ°å½“å‰æ­£åœ¨æ„å»ºçš„å›¾å…ƒä¸­ã€‚
    - ä¾‹å¦‚ï¼Œå¦‚æœå¤„ç†ä¸€ä¸ªç‚¹å¹¶æƒ³ç”Ÿæˆä¸€ä¸ªä¸‰è§’å½¢ï¼Œå°±éœ€è¦è°ƒç”¨Appendä¸‰æ¬¡ï¼Œæ¯æ¬¡ä¼ å…¥ä¸€ä¸ªé¡¶ç‚¹ã€‚
  - ` stream.RestartStrip();`ç»“æŸè¯¥å›¾å…ƒï¼Œç”Ÿæˆæ–°å›¾å…ƒã€‚
    - æ¯”å¦‚ï¼Œæ·»åŠ äº†ä¸‰ä¸ªé¡¶ç‚¹å½¢æˆä¸€ä¸ªä¸‰è§’å½¢åï¼Œè°ƒç”¨`RestartStrip`æ¥ç»“æŸè¿™ä¸ªä¸‰è§’å½¢ï¼Œæ¥ä¸‹æ¥çš„Appendè°ƒç”¨ä¼šå¼€å§‹æ„å»ºæ–°çš„å›¾å…ƒï¼Œä¸‰è§’å½¢æˆ–çº¿æ¡ã€‚

- `GeometryOutput`çš„ä»£ç ï¼š

  - ```C
    struct GeometryOutput
            {
                float4 positionCS : SV_POSITION;
                float3 normalOS   : TEXCOORD0;
            };
    ```



##### æ€»ç»“

- **ä¸€ä¸ªå‡½æ•°ç›´æ¥è°ƒç”¨**
  - `#pragma geometry geom`ï¼šè°ƒç”¨
  - **å‡½æ•°**
    - `[maxvertexcount(3)]`å‰ç½®é¡¶ç‚¹æ•°é‡è®¾ç½®
    - **ä¼ å…¥**
      - `triangle Varyings IN[3]`ï¼šå¤„ç†å¯¹è±¡å’Œç»“æ„ä½“
      - `inout TriangleStream<GeometryOutput> stream`:è¾“å…¥è¾“å‡ºçš„æµï¼Œé€šè¿‡`stream.Append(OUT);`è¿›è¡ŒåŠ æµï¼ŒåŠ å…¥å¯¹åº”æ³›å‹é‡Œçš„ç»“æ„ä½“ã€‚`stream.Append`æ–¹æ³•ç”¨äºå°†æ–°çš„é¡¶ç‚¹æ·»åŠ åˆ°è¾“å‡ºæµä¸­ã€‚



---



#### æ›²é¢ç»†åˆ†+å‡ ä½•ç€è‰²å™¨ç”Ÿæˆäº¤äº’è‰æ¡ˆä¾‹

å‚è€ƒï¼š[Unity Grass ç€è‰²å™¨æ•™ç¨‹ (roystan.net)](https://roystan.net/articles/grass-shader/)

[èœé¸¡éƒ½èƒ½å­¦ä¼šçš„Unityè‰åœ°shader - çŸ¥ä¹ (zhihu.com)](https://zhuanlan.zhihu.com/p/433385999)

1. **å‡ ä½•ç€è‰²å™¨ç”Ÿæˆä¸€ä¸ªç®€å•çš„ä¸‰è§’å½¢**

   - <img src="D:/TyporaImage/image-20250213140854482.png" alt="image-20250213140854482" style="zoom:33%;" />

     ```c
     //----------geo Shader ---------
     [maxvertexcount(3)]
             void geom(
                 triangle Varyings input[3] ,
                 inout TriangleStream<geometryOutput> triStream)
             {
                 geometryOutput output;
                 output = (geometryOutput)0;
                 output.positionCS = TransformObjectToHClip(float4(0.5, 0, 0 , 1));
                 triStream.Append(output);
                 output.positionCS = TransformObjectToHClip(float4(-0.5, 0, 0 , 1));
                 triStream.Append(output);
                 output.positionCS = TransformObjectToHClip(float4(0, 1, 0 , 1));
                 triStream.Append(output);              
             }
     ```

   - ä¸ºäº†ä½¿å¾—åŸæœ¬çš„ç‰©ä½“çš„ç½‘æ ¼èƒ½å¤Ÿæ˜¾ç¤ºå‡ºæ¥ï¼Œéœ€è¦å¯¹ç‰©ä½“åŸæœ‰çš„ä¸‰è§’å½¢è¿›è¡Œéå†

     - å…ˆ`[maxvertexcount(6)]`æ”¹ä¸º6ä¸ª

     - ç„¶åæ·»åŠ 

       ```C
       //----------geo Shader ---------
       //ä¿ç•™åŸå§‹ä¸‰è§’å½¢
       for(int i = 0; i < 3; i++)
       {
                       output.positionCS = input[i].positionCS;
                       output.positionWS = input[i].positionWS;
                       triStream.Append(output);
       }
       triStream.RestartStrip();
       ```

   - ä¿æŒè¿™ä¸ªå°ä¸‰è§’å½¢è€Œä¸æ˜¾ç¤ºåŸæ¥çš„ç½‘æ ¼

2. **åˆ†æ•£ä¸‰è§’å½¢**

   - è®¡ç®—çš„æ—¶å€™æ²¡æœ‰ç”¨åŸå§‹çš„é¡¶ç‚¹ä½ç½®ä½œä¸ºä¸‰è§’å½¢çš„èµ·å§‹ä½ç½®ï¼Œæ‰€ä»¥å¾ˆå¤šå¾ˆå¤šä¸ªé¡¶ç‚¹çš„ä¸‰è§’å½¢éƒ½é•¿åˆ°äº†ä¸€èµ·

     - åŠ å…¥åå€šè§£å†³æ­¤é—®é¢˜<img src="D:/TyporaImage/image-20250213142801322.png" alt="image-20250213142801322" style="zoom:25%;" />

     - ```C
       output.positionCS = TransformObjectToHClip(input[0].positionOS + float3(0.5, 0, 0 ));
       output.positionCS = TransformObjectToHClip(input[0].positionOS + float3(-0.5, 0, 0 ));
       output.positionCS = TransformObjectToHClip(input[0].positionOS + float3(0, 1, 0 ));
       ```

     - åªåœ¨å¹³é¢ä¸Šçœ‹ä¸Šå»æ˜¯å¯¹çš„ï¼Œå®ƒçš„å½¢çŠ¶éƒ½æ˜¯å›ºå®šæœå‘<img src="D:/TyporaImage/image-20250213143019066.png" alt="image-20250213143019066" style="zoom: 33%;" />ï¼ˆåœ†æŸ±ï¼‰

3. **è½¬æ¢åˆ°åˆ‡çº¿ç©ºé—´**

   - æˆ‘ä»¬éœ€è¦è®©ä¸‰è§’å½¢é•¿åœ¨é¡¶ç‚¹ä¸Šï¼Œå¹¶ä¸”èƒ½å¤Ÿåœ¨meshçš„æ‰€å¤„çš„ç©ºé—´ç”Ÿé•¿

     - è‡ªè¡Œæ„å»ºä¸€ä¸ªTBNçŸ©é˜µï¼Œç„¶åå³ä¹˜ï¼ˆå‘ç°å·¦ä¹˜çš„æ—¶å€™æ–¹å‘åè¿‡æ¥äº†ï¼‰

     - ```C
       //----------geo Shader ---------
       
       //ç”¨æ¥å®šä¹‰ç”Ÿæˆè‰å¶çš„ä½ç½®ï¼Œå°è£…å‡½æ•°æ–¹ä¾¿é‡å¤è°ƒç”¨
       inline geometryOutput VertexOutput(float3 positionOS,float2 uv)
       {
       geometryOutput output;
       output.positionCS = TransformObjectToHClip(positionOS);
       output.positionWS = TransformObjectToWorld(positionOS);
       output.uv = uv;
       return output;
       }
       
       float3 positionOS = input[0].positionOS;
       float3 normalOS = input[0].normalOS;
       float4 tangentOS = input[0].tangentOS;
       float3 BinormalOS = normalize(cross(normalOS, tangentOS.xyz) * tangentOS.w);	//ä¹˜åˆ‡çº¿çš„Wåˆ¤æ–­æ–¹å‘ç”¨
       
       float3x3 TBN_T2O = float3x3(tangentOS.xyz,BinormalOS,normalOS);//åˆ—å‘é‡æ’å¸ƒ
       triStream.Append(VertexOutput(positionOS + mul(float3(0.5,0.0,0.0) , TBN_T2O) , float2(0.0,0.0)));
       triStream.Append(VertexOutput(positionOS + mul(float3(-0.5,0.0,0.0) , TBN_T2O) , float2(1.0,0.0)));
       triStream.Append(VertexOutput(positionOS + mul(float3(0.0,0.0,1.0) , TBN_T2O) , float2(0.5,1.0))); 
       ```

       - å†™äº†ä¸€ä¸ªé¢å¤–çš„å†…ç½®å‡½æ•°ï¼Œæ–¹ä¾¿é‡å¤è°ƒç”¨
       - UVç”¨æ¥åé¢åšæ¸å˜
         - UVé•¿è¿™æ ·ï¼Œé€†æ—¶é’ˆä¸‰è§’å½¢ï¼š<img src="D:/TyporaImage/grass-uv.png" alt="img" style="zoom:33%;" />

     - ç„¶åç”¨UVæ¥lerpè¾“å‡ºé¢œè‰²

       - <img src="D:/TyporaImage/image-20250213152313913.png" alt="image-20250213152313913" style="zoom:25%;" />

       - ```C
         half4 frag_Common (geometryOutput input) : SV_Target
         {
         return lerp(_BottomColor, _TopColor, input.uv.y);
         }
         ```

4. **éšæœºæ•°çš„åº”ç”¨**

   - **éšæœºæ•°ç”Ÿæˆ**

     ```C
     //éšæœºæ•°ç”Ÿæˆå‡½æ•°â€”â€”è¾“å‡º[0,1]
     inline float rand(float3 co)
     {
     return frac(sin(dot(co.xyz, float3(12.9898,78.233,45.5432))) * 43758.5453);
     }
     ```

     - åé¢å†ä¹˜ä¸ª2Ï€ï¼Œ

   - **è½´æ—‹è½¬çŸ©é˜µ**

     ```c
     //å›´ç»•è½´æ—‹è½¬çŸ©é˜µâ€”â€”ç½—å¾·é‡Œæ ¼æ–¯æ—‹è½¬çŸ©é˜µ
     inline float3x3 AngleAxis3x3(float angle , float3 axis)
             {
                 float c,s;
                 sincos(angle , s , c);
                 float t = 1.0 - c;
                 float x = axis.x;
                 float y = axis.y;
                 float z = axis.z;
                 return float3x3(
                     t*x*x + c, t*x*y - s*z, t*x*z + s*y,
                     t*x*y + s*z, t*y*y + c, t*y*z - s*x,
                     t*x*z - s*y, t*y*z + s*x, t*z*z + c
                 );
             }
     ```

   - **åº”ç”¨éšæœºæ—‹è½¬è½´**

     ```C
     //----------geo Shader ---------
     
     //éšæœºæ—‹è½¬è§’åº¦
     float3x3 facingRotationMatrix = AngleAxis3x3(rand(positionOS + _RotateSeed.xyz) * CUSTOM_TWO_PI, float3(0.0,0.0,1.0));
     //éšæœºæ—‹è½¬çŸ©é˜µå’ŒTBNçŸ©é˜µç›¸ä¹˜ï¼ˆéœ€è€ƒè™‘é¡ºåºï¼Œè¿™é‡Œæ˜¯å³ä¹˜ï¼‰
     float3x3 transformationMatrix = mul(facingRotationMatrix,TBN_T2O);
     
     triStream.Append(VertexOutput(positionOS + mul(float3(0.5,0.0,0.0) , transformationMatrix) , float2(0.0,0.0)));
     ```

   - **åº”ç”¨éšæœºå¼¯æŠ˜**

     ```C
     //----------geo Shader ---------
     
     float3x3 bendRotationMatrix = AngleAxis3x3(rand(positionOS + _RotateSeed.yzx) * CUSTOM_PI * _BendRotationRandom * 0.5 , float3(-1.0,0.0,0.0));
     
     //çŸ©é˜µçš„æ··åˆï¼ˆéœ€è€ƒè™‘é¡ºåºï¼‰
     float3x3 transformationMatrix = mul(bendRotationMatrix,mul(facingRotationMatrix,TBN_T2O));
     ```

   - **åº”ç”¨éšæœºé«˜åº¦å®½åº¦**

     ```c
     //----------geo Shader ---------
     //éšæœºå®½é«˜
     float height = (rand(positionOS.xyz) * 2 - 1) * _BladeHeightRandom + _BladeHeight  ;
     float width = (rand(positionOS.xyz) * 2 - 1) * _BladeWidthRandom + _BladeWidth ;
     
     //é€†æ—¶é’ˆä¸‰è§’å½¢
     triStream.Append(VertexOutput(positionOS + mul(float3(-width,0.0,0.0) , transformationMatrix) , float2(0.0,0.0)));
     triStream.Append(VertexOutput(positionOS + mul(float3(width,0.0,0.0) , transformationMatrix) , float2(1.0,0.0)));
     triStream.Append(VertexOutput(positionOS + mul(float3(0.0,0.0,height) , transformationMatrix) , float2(0.5,1.0))); 
     ```

   - **æ•ˆæœ**

     - <img src="D:/TyporaImage/image-20250213163035926.png" alt="image-20250213163035926" style="zoom:33%;" />
     - æ¯ä¸ªé¡¶ç‚¹æœ‰**éšæœºæœå‘ï¼Œéšæœºå®½åº¦ï¼Œéšæœºé«˜åº¦**
     - ä¸‹ä¸€æ­¥å¢åŠ é¡¶ç‚¹

5. **æ›²é¢ç»†åˆ†å¢åŠ é¡¶ç‚¹**

   - <img src="D:/TyporaImage/image-20250213204500585.png" alt="image-20250213204500585" style="zoom:33%;" />

   - æŠŠä¹‹å‰çš„æ›²é¢ç»†åˆ†çš„ä»£ç å¤åˆ¶ç²˜è´´è¿‡æ¥ï¼Œä¸»è¦æ˜¯ç”Ÿæˆæ›´å¤šçš„é¡¶ç‚¹ã€‚

     - ```c
       
       struct Tess_Attributes
       {
           float4 positionOS : POSITION;
           float2 texcoord   : TEXCOORD0;
           float3 normalOS   : NORMAL;
           float4 tangentOS  : TANGENT;
       };
       struct Tess_Varyings
       {
           float4 positionCS : SV_POSITION;
           float3 positionWS : TEXCOORD0;
           float3 positionOS : TEXCOORD1;
           float2 uv         : TEXCOORD2;
           float3 normalOS   : TEXCOORD3;
           float4 tangentOS  : TEXCOORD4;
       };
       
       struct Tess_ControlPoint //è¿™ä¸ªç»“æ„ä½“ä½œä¸ºHull Shaderçš„è¾“å…¥/è¾“å‡ºæ§åˆ¶ç‚¹
       {
           float4 positionOS : INTERNALTESSPOS;  
           float2 uv         : TEXCOORD0;
           float3 normalOS   : TEXCOORD1;
           float4 tangentOS  : TEXCOORD2;
       };
       
       struct Tess_TessFactors  //ç»†åˆ†å› å­
       {
           float edge[3] : SV_TessFactor;  //ä¸‰ä¸ªç»†åˆ†å› å­
           float inside  : SV_InsideTessFactor;    //ç¬¬å››ä¸ªç»†åˆ†å› å­
       };
       
       struct Tess_DomainAttributes
       {
           float4 positionOS : TEXCOORD0;
           float2 uv         : TEXCOORD1;
           float3 normalOS   : TEXCOORD2;
           float4 tangentOS  : TEXCOORD3;
       };
       
       Tess_ControlPoint vert_Tess(Tess_Attributes IN)
               {
                   Tess_ControlPoint OUT;
                   OUT.positionOS = IN.positionOS;
                   OUT.uv = IN.texcoord;
                   OUT.normalOS = IN.normalOS;
                   OUT.tangentOS = IN.tangentOS;
                   return OUT;
               }
       
               [domain("tri")]      //æŒ‡å®špatchçš„ç±»å‹
               [outputcontrolpoints(3)]    //æŒ‡å®šè¾“å‡ºçš„æ§åˆ¶ç‚¹çš„æ•°é‡ï¼ˆæ¯ä¸ªå›¾å…ƒï¼‰
               [patchconstantfunc("patchConstantFunc")]    //æŒ‡å®šé¢ç‰‡å¸¸æ•°å‡½æ•°ã€‚
               [outputtopology("triangle_cw")] //è¾“å‡ºæ‹“æ‰‘ç»“æ„ã€‚
               [partitioning("integer")]   //åˆ†å‰²æ¨¡å¼ï¼Œèµ·åˆ°å‘ŠçŸ¥GPUåº”è¯¥å¦‚ä½•åˆ†å‰²è¡¥ä¸çš„ä½œç”¨ã€‚ç¡¬åˆ†å‰²
               Tess_ControlPoint hull_Tess(
                   InputPatch<Tess_ControlPoint, 3> patch,  //å‘Hull ç¨‹åºä¼ é€’æ›²é¢è¡¥ä¸çš„å‚æ•°
                   uint id : SV_OutputControlPointID)
               {
                   return patch[id];
               }
       
               Tess_TessFactors patchConstantFunc(InputPatch<Tess_ControlPoint, 3> patch)    //å†³å®šäº†Patchçš„å±æ€§æ˜¯å¦‚ä½•è¢«ç»†åˆ†çš„ï¼Œæ¯ä¸ªPatchè°ƒç”¨ä¸€æ¬¡
               {
                   Tess_TessFactors OUT;
       
                   OUT.edge[0] = OUT.edge[1] = OUT.edge[2] = _TessFactor;  //æ§åˆ¶ä¸‰è§’å½¢æ¯æ¡è¾¹çš„ç»†åˆ†æ•°é‡
                   OUT.inside = _TessFactor;   //æ§åˆ¶å†…éƒ¨è¾¹çš„ç»†åˆ†æ•°é‡
       
                   return OUT;
               }
       
               //Domainyç€è‰²å™¨ï¼ŒDomainâ†’Geometry
               Tess_Varyings vert_AfterTess(Tess_DomainAttributes IN)
               {
                   Tess_Varyings OUT;
       
                   OUT.positionWS = TransformObjectToWorld(IN.positionOS);
                   OUT.positionCS = TransformWorldToHClip(OUT.positionWS);
                   OUT.positionOS = IN.positionOS;
                   OUT.uv = IN.uv;
                   OUT.normalOS = IN.normalOS;
                   OUT.tangentOS = IN.tangentOS;
       
                   return OUT;
               }
       
               [domain("tri")]
               Tess_Varyings domain_Tess(
                   Tess_TessFactors factors,    //ç”±patchConstantFuncå‡½æ•°ç”Ÿæˆçš„ç»†åˆ†å› å­
                   OutputPatch<Tess_ControlPoint, 3> patch,     //Hullç€è‰²å™¨ä¼ å…¥çš„patchæ•°æ®ã€‚ç¬¬äºŒä¸ªå‚æ•°éœ€è¦å’ŒInputPatchç¬¬äºŒä¸ªå‚æ•°å¯¹åº”
                   float3 barycentricCoordinates : SV_DomainLocation)  //ç”±æ›²é¢ç»†åˆ†é˜¶æ®µé˜¶æ®µä¼ å…¥çš„é¡¶ç‚¹ä½ç½®ä¿¡æ¯
               {
                   Tess_DomainAttributes OUT;
                   //åˆå§‹åŒ–OUT
                   OUT = (Tess_DomainAttributes)0;
       
                   //æ ¹æ®é‡å¿ƒåæ ‡æ’å…¥æ³•çº¿æ•°æ®
       OUT.normalOS = patch[0].normalOS * barycentricCoordinates.x + 
       patch[1].normalOS * barycentricCoordinates.y + 
       patch[2].normalOS * barycentricCoordinates.z;
                   //æ ¹æ®é‡å¿ƒåæ ‡è¿›è¡Œä½ç½®
       OUT.positionOS = patch[0].positionOS * barycentricCoordinates.x + 
       patch[1].positionOS * barycentricCoordinates.y + 
       patch[2].positionOS * barycentricCoordinates.z;
                   //æ ¹æ®é‡å¿ƒåæ ‡æ’å…¥åˆ‡çº¿æ•°æ®
       OUT.tangentOS = patch[0].tangentOS * barycentricCoordinates.x + 
       patch[1].tangentOS * barycentricCoordinates.y + 
       patch[2].tangentOS * barycentricCoordinates.z;
                   //æ ¹æ®é‡å¿ƒåæ ‡æ’å…¥UV   
       OUT.uv = patch[0].uv * barycentricCoordinates.x + 
       patch[1].uv * barycentricCoordinates.y + 
       patch[2].uv * barycentricCoordinates.z;
       return vert_AfterTess(OUT);
               }
       ```

     - å› ä¸ºå¯¹ç»“æ„è¿›è¡Œäº†è°ƒæ•´ï¼Œæ‰€ä»¥éœ€è¦å¤åˆ¶ç²˜è´´æ–°çš„ç»“æ„ä½“ï¼Œå¹¶ä¸”æŠŠåŸå§‹çš„`Attributes`ç»“æ„ä½“ï¼Œ`Varyings`ç»“æ„ä½“ä»¥åŠåŸå§‹çš„é¡¶ç‚¹ç€è‰²å™¨`vert_Common`æ³¨é‡Šæ‰ï¼Œä½¿ç”¨Tesselationçš„`Tess_Attributes`ç»“æ„ä½“ï¼Œ`Tess_Varyings`ç»“æ„ä½“å’Œ`vert_Tess`é¡¶ç‚¹ç€è‰²å™¨ã€‚

     - `void geom(triangle Varyings input[3],inout TriangleStream<geometryOutput> triStream)` é‡Œé¢çš„`Varyings `ç»“æ„ä½“ä¿®æ”¹æˆæ›²é¢ç»†åˆ†ä¼ è¿‡æ¥çš„`Tess_Varyings`ç»“æ„ä½“

     - æ­¤æ—¶çš„ç¼–è¯‘ä¿®æ”¹ä¸ºï¼š

       ```C
       #pragma vertex vert_Tess	//æ›²é¢ç»†åˆ†çš„é¡¶ç‚¹shader
       #pragma hull hull_Tess	//Hullâ†’Domain
       #pragma domain domain_Tess	//Domainâ†’Geometry
       #pragma geometry geom	//Geometryâ†’Vertex
       #pragma fragment frag_Common	//ä¿æŒåŸç‰ˆçš„ç‰‡å…ƒç€è‰²å™¨
       ```

   - **æ•ˆæœ**

     - ![åŠ¨ç”»](D:/TyporaImage/%E5%8A%A8%E7%94%BB-1739451423843-1.gif)

6. **æ·»åŠ é£åŠ¨æ•ˆæœ**

   - ```C
      //UV
     float2 uv = positionOS.xz * _WindDistortionMap_ST.xy + _WindDistortionMap_ST.zw + _WindFrequency.xy * _Time.y;
     //Wind Construct
     float2 windSample = SAMPLE_TEXTURE2D_LOD(_WindDistortionMap, sampler_WindDistortionMap, uv * 2 - 1, 0) * _WindStrength;
     float3 wind = normalize(float3(windSample.x,windSample.y,0.0));//wind Vector
     float3x3 windRotationMatrix = AngleAxis3x3(CUSTOM_PI * windSample,wind);
     
     //çŸ©é˜µçš„æ··åˆï¼ˆéœ€è€ƒè™‘é¡ºåºï¼‰
     float3x3 transformationMatrix = mul(windRotationMatrix,mul(facingRotationMatrix,mul(bendRotationMatrix,TBN_T2O)));
     float3x3 transformationMatrixFacing = mul(facingRotationMatrix,TBN_T2O);//ç”¨äºåº•éƒ¨çš„ä¸¤ä¸ªé¡¶ç‚¹ç‰¹æ®Šå¤„ç†ï¼Œä¸è®©å…¶é£åŠ¨å’Œå¼¯æ›²
     
     triStream.Append(VertexOutput(positionOS + mul(float3(-width,0.0,0.0) , transformationMatrixFacing) , float2(0.0,0.0)));//ä¸¤ä¸ªåº•éƒ¨çš„é¡¶ç‚¹ä¸åšé£åŠ¨æ•ˆæœä»¥åŠå¼¯æŠ˜
     triStream
         .Append(VertexOutput(positionOS + mul(float3(width,0.0,0.0) , transformationMatrixFacing) , float2(1.0,0.0)));
     ```

     - å› ä¸ºä¸èƒ½è®©åº•éƒ¨çš„ä¸¤ä¸ªé¡¶ç‚¹å—åˆ°é£åŠ¨ï¼Œå› æ­¤å¯¹äºå®ƒä¿©é‡‡ç”¨ä¸åŒçš„çŸ©é˜µï¼Œå¹¶ä¸”åŠ å…¥åˆ°`triStream.Append`ä¸­
     - é‡‡æ ·äº†ä¸€å¼ `_WindDistortionMap`<img src="D:/TyporaImage/v2-1b2e2456e538b2a83ecfcb3b5c56a3b6_r.jpg" alt="v2-1b2e2456e538b2a83ecfcb3b5c56a3b6_r" style="zoom:25%;" />
     - **æ•ˆæœ**
       - ![åŠ¨ç”»](D:/TyporaImage/%E5%8A%A8%E7%94%BB-1739504355509-2.gif)

7. **è‰å¶çš„æ›²ç‡ï¼Œå¤šç‰‡è‰å¶**

   - <img src="D:/TyporaImage/grass-construction.gif" alt="img" style="zoom:25%;" />

   - **ä»£ç **

      - ```C
         for(int i = 0; i < BLADE_SEGMENTS; i++)
         {
         float t = i / (float)BLADE_SEGMENTS;
         float segmentHeight = height * t;
         float segmentWidth = width * (1 - t);
         //åº•éƒ¨çš„ä¸¤ä¸ªé¡¶ç‚¹ä¸åŠ¨ï¼Œä¹Ÿå°±æ˜¯i = 0çš„æƒ…å†µ
         float3x3 transformationMatrix_T = i == 0 ? transformationMatrixFacing : transformationMatrix;
         triStream.Append(GenerateGrassVertex(positionOS , segmentWidth , segmentHeight , float2(0.0,t) , transformationMatrix_T));//ä¸¤ä¸ªåº•éƒ¨çš„é¡¶ç‚¹ä¸åšé£åŠ¨æ•ˆæœä»¥åŠå¼¯æŠ˜
         triStream.Append(GenerateGrassVertex(positionOS , -segmentWidth , segmentHeight , float2(1.0,t) , transformationMatrix_T));
         }
         //æœ€åä¸€ä¸ªé¡¶ç‚¹çš„ä¸‰è§’å½¢
         triStream.Append(GenerateGrassVertex(positionOS , 0.0 , height , float2(0.5,1.0) , transformationMatrix)); 
         ```

         - åœ¨ä¸‰è§’å½¢Streamä¹‹å‰ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ª**forå¾ªç¯**æ¥å¢åŠ é¡¶ç‚¹ï¼š
           - å¾ªç¯çš„æ¯ä¸€æ¬¡è¿­ä»£éƒ½ä¼šå¢åŠ ä¸¤ä¸ªé¡¶ç‚¹ï¼šä¸€ä¸ªæ˜¯å·¦è¾¹ï¼Œä¸€ä¸ªæ˜¯å³è¾¹ã€‚
           - åœ¨é¡¶éƒ¨å®Œæˆåï¼Œæˆ‘ä»¬å°†åœ¨å¶ç‰‡çš„é¡¶ç«¯æ·»åŠ æœ€åä¸€ä¸ªé¡¶ç‚¹ã€‚
             - åœ¨uvä¸Šï¼Œå®ƒå®é™…ä¸Šæ˜¯ä»ä¸‹å¾€ä¸Šçš„çŸ©å½¢ã€‚è€Œé¡¶ç‚¹çš„ç”Ÿæˆä¸Šï¼Œå› ä¸ºæ˜¯å®½é«˜å‘ç”Ÿäº†å˜åŒ–ï¼Œæ‰€ä»¥çœ‹ä¸Šå»å¥½åƒå‘å†…æ”¶ç¼©äº†ä¸€æ ·ã€‚
         - ç›®å‰è¿˜ç¼ºå°‘ä¸€ä¸ªè½´å‘çš„ä¿¡æ¯ï¼Œå‰åçš„Zè½´çš„ä¿¡æ¯ï¼Œæˆ‘ä»¬æ‹¿æ¥åšå¼¯æ›²ç”¨ã€‚

   - **æ•ˆæœ**

      - ![image-20250214134943105](D:/TyporaImage/image-20250214134943105.png)


   - **å¼¯æ›²**

     - æ–°å¢ä¸€ä¸ªæ„é€ å‡½æ•°ï¼Œæ·»åŠ äº†æ–°çš„å‚æ•°`Forward`

       - ```C
         inline geometryOutput GenerateGrassVertex(float3 vertexPositionOS , float width , float height ,float forward , float2 uv , float3x3 transformationMatrix)
                 {
                     float3 tangentPoint = float3(width , forward , height);
         
                     float3 localPositionOS = vertexPositionOS + mul(tangentPoint , transformationMatrix);
                     return VertexOutput(localPositionOS,uv);
                 }
         ```

     - ä¿®æ”¹ä¸€ä¸‹åŸæ¥çš„å‡½æ•°

       - ```C
         // Add as new properties.
         _BladeForward("Blade Forward Amount", Float) = 0.38
         _BladeCurve("Blade Curvature Amount", Range(1, 4)) = 2
         
         â€¦
         
         // Add to the CGINCLUDE block.
         float _BladeForward;
         float _BladeCurve;
         
         â€¦
         
         // Add inside the geometry shader, below the line declaring float width.
         float forward = rand(pos.yyz) * _BladeForward;
         
         â€¦
         
         // è¿™ä¸ªå†™åˆ°å¾ªç¯é‡Œé¢å»
         float segmentForward = pow(t, _BladeCurve) * forward;
         
         â€¦
         
         // Modify the GenerateGrassVertex calls inside the loop.
         triStream.Append(GenerateGrassVertex(pos, segmentWidth, segmentHeight, segmentForward, float2(0, t), transformMatrix));
         triStream.Append(GenerateGrassVertex(pos, -segmentWidth, segmentHeight, segmentForward, float2(1, t), transformMatrix));
         
         â€¦
         
         // Modify the GenerateGrassVertex calls outside the loop.
         triStream.Append(GenerateGrassVertex(pos, 0, height, forward, float2(0.5, 1), transformationMatrix));
         ```

       - **æ•ˆæœ**

         - ![image-20250214141248546](D:/TyporaImage/image-20250214141248546.png)
           - å¯ä»¥çœ‹åˆ°å·²ç»æœ‰æ®µè½å¼å¼¯æ›²çš„æ„Ÿè§‰äº†

8. **å…‰ç…§ä¸é˜´å½±**

   - æ–°å»ºäº†ä¸€ä¸ªpasså³å¯æŠ•å½±

      - ```C
         Pass
                 {
                     Tags
                     {
                         "LightMode" = "ShadowCaster"
                     }
         
                     HLSLPROGRAM
         
                     #pragma vertex vert_Tess
                     #pragma hull hull_Tess
                     #pragma domain domain_Tess
                     #pragma geometry geom
                     #pragma fragment frag_Common
                     #pragma multi_compile_shadowcaster
         
                     ENDHLSL
         
                 }
         ```

         ![image-20250214154834705](D:/TyporaImage/image-20250214154834705.png)

   - **æ¥æ”¶é˜´å½±**

      - é¢

      - **æ•ˆæœ**

         - ![image-20250214170820006](D:/TyporaImage/image-20250214170820006.png)

            - å¯ä»¥æ­£ç¡®çš„æ¥æ”¶å’ŒæŠ•å°„é˜´å½±äº†
            - ä½†æ˜¯è‡ªå·±å¯¹è‡ªå·±çš„é®æŒ¡ï¼Œä½¿å¾—å®ƒäº§ç”Ÿäº†ä¸€ä¸ªä¸ªæ¡çº¹![img](D:/TyporaImage/shadow-bias.gif)

         - **è§£å†³æ–¹æ³•**

            - ```C
               //åœ¨VertexOutputçš„Returnçš„ä¸Šé¢ï¼Œå¯¹å…¶è¿›è¡Œé˜´å½±åç§»
               //å…‰ç…§æ•°æ®
               Light mainLight = GetMainLight();
               float3 lightDir = normalize(mainLight.direction).xyz;
               
               //ç¡®ä¿åªåœ¨é˜´å½±é€šé“çš„æ—¶å€™æ‰è¿›è¡Œç¨å¾®çš„åç§»
               #if UNITY_PASS_SHADOWCASTER
               output.positionWS = float4(ApplyShadowBias(output.positionWS,output.normalWS,lightDir) , 1.0);
               #endif
               ```

            - **æ•ˆæœ**

               - <img src="D:/TyporaImage/image-20250214175419007.png" alt="image-20250214175419007" style="zoom:33%;" />

   - **å…‰ç…§è®¡ç®—**

      - **è®¡ç®—éœ€è¦ç¡®ä¿æ³•çº¿çš„æ­£ç¡®ã€‚**

         - è¿ç”¨ä¹‹å‰åº•éƒ¨é¡¶ç‚¹çš„æ³•çº¿ç»™æ‰€æœ‰çš„ç‚¹ï¼š<img src="D:/TyporaImage/image-20250214181516316.png" alt="image-20250214181516316" style="zoom:25%;" />

            ```C
            return VertexOutput(localPositionOS,uv,normalOS);	//ç›´æ¥returnä¼ è¿‡æ¥çš„æ³•çº¿æ•°æ®
            ```

            - æ¯ä¸ªé¡¶ç‚¹éƒ½æ˜¯åŒæ ·çš„å‘ç°æ•°æ®

         - ä¸ºæ¯ä¸€ä¸ªé¡¶ç‚¹è®¾ç½®ç›¸åŒçš„æ•°æ®ï¼Œç„¶åç»Ÿä¸€åº”ç”¨åŸæ¥çš„æ—‹è½¬ç¼©æ”¾çŸ©é˜µï¼š<img src="D:/TyporaImage/image-20250214181648344.png" alt="image-20250214181648344" style="zoom:25%;" />

            - æ¯ä¸ªé¡¶ç‚¹æœ‰å„è‡ªçš„æ³•çº¿æ•°æ®ï¼Œæ¥ä¸‹æ¥æ‰èƒ½æ­£ç¡®çš„è®¡ç®—å…‰ç…§

      - æœ€åç›´æ¥è¿›è¡Œå…‰ç…§è®¡ç®—å³å¯

         - ```C
                        //é˜´å½±æ•°æ®
            float4 shadowCoord = input.shadowCoord;
            half shadow = MainLightRealtimeShadow(shadowCoord); 
            
                        //å…‰ç…§æ•°æ®
            Light mainLight = GetMainLight();
            float3 lightDir = normalize(mainLight.direction).xyz;
            
            float NdotL = saturate(dot(normalWS, lightDir)) * shadow;
            
            float3 ambient = SampleSH(normalWS);
            float4 lightTerm = float4(( NdotL * mainLight.color + ambient)  , 1.0);
            
            half4 color = lerp(_BottomColor, _TopColor * lightTerm , input.uv.y);
            
            return color ;
            ```

9. **æœ€ç»ˆæ•ˆæœ**

   - ![åŠ¨ç”»](D:/TyporaImage/%E5%8A%A8%E7%94%BB-1739529747483-8.gif)

   - **æœ€ç»ˆä»£ç **

      - `CustomTess.HLSL`

         - ```c
            #ifndef CUSTOM_UNIVERSAL_PIPELINE_TESSELLATION_SHADER
            #define CUSTOM_UNIVERSAL_PIPELINE_TESSELLATION_SHADER
            
            
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
            
            
            //==========================================
            // æ›²é¢ç»†åˆ†æ•°æ®ç»“æ„
            //==========================================
            
            struct Tess_Attributes
            {
                float4 positionOS : POSITION;
                float2 texcoord   : TEXCOORD0;
                float3 normalOS   : NORMAL;
                float4 tangentOS  : TANGENT;
            };
            struct Tess_Varyings
            {
                float4 positionCS : SV_POSITION;
                float3 positionWS : TEXCOORD0;
                float3 positionOS : TEXCOORD1;
                float2 uv         : TEXCOORD2;
                float3 normalOS   : TEXCOORD3;
                float4 tangentOS  : TEXCOORD4;
            };
            
            struct Tess_ControlPoint //è¿™ä¸ªç»“æ„ä½“ä½œä¸ºHull Shaderçš„è¾“å…¥/è¾“å‡ºæ§åˆ¶ç‚¹
            {
                float4 positionOS : INTERNALTESSPOS;  
                float2 uv         : TEXCOORD0;
                float3 normalOS   : TEXCOORD1;
                float4 tangentOS  : TEXCOORD2;
            };
            
            struct Tess_TessFactors  //ç»†åˆ†å› å­
            {
                float edge[3] : SV_TessFactor;  //ä¸‰ä¸ªç»†åˆ†å› å­
                float inside  : SV_InsideTessFactor;    //ç¬¬å››ä¸ªç»†åˆ†å› å­
            };
            
            struct Tess_DomainAttributes
            {
                float4 positionOS : TEXCOORD0;
                float2 uv         : TEXCOORD1;
                float3 normalOS   : TEXCOORD2;
                float4 tangentOS  : TEXCOORD3;
            };
            
            #endif
            ```

      - `TessGeo_Grass.Shader`

         - ```C
            Shader "Study/URP/Text/3.3 TessGeo Grass"
            {
                Properties
                {
                    [Space(20)]
                    [Header(Colors)]
                    _BottomColor ("Bottom Color", Color) = (1,1,1,1)
                    _TopColor ("Top Color", Color) = (1,1,1,1)
            
                    [Space(20)]
                    [Header(Noise)]
                    _RotateSeed ("Rotate Seed", Vector) = (0,0,0,0)
                    _BendRotationRandom("Bend Rotation Random", Range(0,1)) = 0.5
                    _BladeWidth ("Blade Width", Range(0,1)) = 0.5
                    _BladeWidthRandom ("Blade Width Random", Range(0,1)) = 0.5
                    _BladeHeight ("Blade Height", Range(0,1)) = 0.5 
                    _BladeHeightRandom ("Blade Height Random", Range(0,1)) = 0.5
            
                    [Space(20)]
                    [Header(Tessellation)]
                    _TessFactor ("Tessellation Factor", Range(1,64)) = 16
            
                    [Space(20)]
                    [Header(Wind)]
                    _WindDistortionMap ("Wind Distortion Map", 2D) = "white" {}
                    _WindFrequency ("Wind Frequency", Vector) = (0.05,0.05,0.0,0.0)
                    _WindStrength ("Wind Strength", Range(0,1)) = 1
            
                    [Space(20)]
                    [Header(Blade)]
                    _BladeForward ("Blade Forward", float) = 0.38
                    _BladeCurve ("Blade Curve", Range(1,4)) = 1
                        
                    [Space(20)]
                    [Header(Interaction)]
                    _Radius ("Radius", Range(0,10)) = 0.5
            
                }
                SubShader
                {
                    Cull Off
                    ZTest LEqual
                    ZWrite On
                    Tags 
                    { 
                        "RenderType"="Opaque" 
                        "RenderPipeline" = "UniversalRenderPipeline"
                    }
            
                    HLSLINCLUDE
            
                    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
                    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
                    #include "Assets/MyStudy/Scene/EverybodyAddsFuel/3.3 TessAndGeom/CustomTess.hlsl"
                    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl"
            
            
                    #pragma target 4.6
                    #pragma multi_compile _ _MAIN_LIGHT_SHADOWS
                    #pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE
                    #pragma multi_compile _ _SHADOWS_SOFT
                    #pragma multi_compile _ _Anti ALIASING
                    #pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS
            
                    #define CUSTOM_TWO_PI 6.283185307179586
                    #define CUSTOM_PI 3.141592653589793
                    #define BLADE_SEGMENTS 3
            
                    TEXTURE2D(_WindDistortionMap);
                    SAMPLER(sampler_WindDistortionMap);
            
                    CBUFFER_START(UnityPerMaterial)
                    uniform half4 _BottomColor ;
                    uniform half4 _TopColor ;
                    uniform float4 _RotateSeed ;
                    uniform half _BendRotationRandom ;
                    uniform half _BladeWidth ;
                    uniform half _BladeWidthRandom ;
                    uniform half _BladeHeight ;
                    uniform half _BladeHeightRandom ;
                    uniform half _BladeForward ;
                    uniform half _BladeCurve ;
                    uniform half _TessFactor ;
                    uniform float2 _WindFrequency ;
                    uniform half _WindStrength ;
                    uniform float4 _WindDistortionMap_ST;
                    uniform float4 _PositionMoving;
                    CBUFFER_END
            
                    //Geo Struct
                    struct geometryOutput
                    {
                        float4 positionCS  : SV_POSITION;
                        float3 positionWS  : TEXCOORD0;
                        float2 uv          : TEXCOORD1;
                        float4 shadowCoord : TEXCOORD2; //é˜´å½±åæ ‡
                        float3 normalWS    : TEXCOORD3;
                    };
            
                    //éšæœºæ•°ç”Ÿæˆå‡½æ•°â€”â€”è¾“å‡º[0,1]
                    inline float rand(float3 co)
                    {
                        return frac(sin(dot(co.xyz, float3(12.9898,78.233,45.5432))) * 43758.5453);
                    }
            
                    //å›´ç»•è½´æ—‹è½¬çŸ©é˜µ
                    inline float3x3 AngleAxis3x3(float angle , float3 axis)
                    {
                        float c,s;
                        sincos(angle , s , c);
            
                        float t = 1.0 - c;
                        float x = axis.x;
                        float y = axis.y;
                        float z = axis.z;
            
                        return float3x3(
                            t*x*x + c, t*x*y - s*z, t*x*z + s*y,
                            t*x*y + s*z, t*y*y + c, t*y*z - s*x,
                            t*x*z - s*y, t*y*z + s*x, t*z*z + c
                        );
                    }
            
                    //==========================================
                    // æ›²é¢ç»†åˆ†éƒ¨åˆ†
                    //==========================================
                    // é¡¶ç‚¹ç€è‰²å™¨ï¼Œé¡¶ç‚¹â†’Hull
                    Tess_ControlPoint vert_Tess(Tess_Attributes IN)
                    {
                        Tess_ControlPoint OUT;
                        OUT.positionOS = IN.positionOS;
                        OUT.uv = IN.texcoord;
                        OUT.normalOS = IN.normalOS;
                        OUT.tangentOS = IN.tangentOS;
                        return OUT;
                    }
            
                    //Hullç€è‰²å™¨ï¼ŒHullâ†’Domain
                    [domain("tri")]      //æŒ‡å®špatchçš„ç±»å‹
                    [outputcontrolpoints(3)]    //æŒ‡å®šè¾“å‡ºçš„æ§åˆ¶ç‚¹çš„æ•°é‡ï¼ˆæ¯ä¸ªå›¾å…ƒï¼‰
                    [patchconstantfunc("patchConstantFunc")]    //æŒ‡å®šé¢ç‰‡å¸¸æ•°å‡½æ•°ã€‚
                    [outputtopology("triangle_cw")] //è¾“å‡ºæ‹“æ‰‘ç»“æ„ã€‚
                    [partitioning("integer")]   //åˆ†å‰²æ¨¡å¼ï¼Œèµ·åˆ°å‘ŠçŸ¥GPUåº”è¯¥å¦‚ä½•åˆ†å‰²è¡¥ä¸çš„ä½œç”¨ã€‚ç¡¬åˆ†å‰²
                    Tess_ControlPoint hull_Tess(
                        InputPatch<Tess_ControlPoint, 3> patch,  //å‘Hull ç¨‹åºä¼ é€’æ›²é¢è¡¥ä¸çš„å‚æ•°
                        uint id : SV_OutputControlPointID)
                    {
                        return patch[id];
                    }
            
                    Tess_TessFactors patchConstantFunc(InputPatch<Tess_ControlPoint, 3> patch)    //å†³å®šäº†Patchçš„å±æ€§æ˜¯å¦‚ä½•è¢«ç»†åˆ†çš„ï¼Œæ¯ä¸ªPatchè°ƒç”¨ä¸€æ¬¡
                    {
                        Tess_TessFactors OUT;
            
                        OUT.edge[0] = OUT.edge[1] = OUT.edge[2] = _TessFactor;  //æ§åˆ¶ä¸‰è§’å½¢æ¯æ¡è¾¹çš„ç»†åˆ†æ•°é‡
                        OUT.inside = _TessFactor;   //æ§åˆ¶å†…éƒ¨è¾¹çš„ç»†åˆ†æ•°é‡
            
                        return OUT;
                    }
            
                    //Domainyç€è‰²å™¨ï¼ŒDomainâ†’Geometry
                    Tess_Varyings vert_AfterTess(Tess_DomainAttributes IN)
                    {
                        Tess_Varyings OUT;
            
                        OUT.positionWS = TransformObjectToWorld(IN.positionOS);
                        OUT.positionCS = TransformWorldToHClip(OUT.positionWS);
                        OUT.positionOS = IN.positionOS;
                        OUT.uv = IN.uv;
                        OUT.normalOS = IN.normalOS;
                        OUT.tangentOS = IN.tangentOS;
            
                        return OUT;
                    }
            
                    [domain("tri")]
                    Tess_Varyings domain_Tess(
                        Tess_TessFactors factors,    //ç”±patchConstantFuncå‡½æ•°ç”Ÿæˆçš„ç»†åˆ†å› å­
                        OutputPatch<Tess_ControlPoint, 3> patch,     //Hullç€è‰²å™¨ä¼ å…¥çš„patchæ•°æ®ã€‚ç¬¬äºŒä¸ªå‚æ•°éœ€è¦å’ŒInputPatchç¬¬äºŒä¸ªå‚æ•°å¯¹åº”
                        float3 barycentricCoordinates : SV_DomainLocation)  //ç”±æ›²é¢ç»†åˆ†é˜¶æ®µé˜¶æ®µä¼ å…¥çš„é¡¶ç‚¹ä½ç½®ä¿¡æ¯
                    {
                        Tess_DomainAttributes OUT;
                        //åˆå§‹åŒ–OUT
                        OUT = (Tess_DomainAttributes)0;
            
                        //æ ¹æ®é‡å¿ƒåæ ‡æ’å…¥æ³•çº¿æ•°æ®
                        OUT.normalOS = patch[0].normalOS * barycentricCoordinates.x + 
                                          patch[1].normalOS * barycentricCoordinates.y + 
                                          patch[2].normalOS * barycentricCoordinates.z;
                        //æ ¹æ®é‡å¿ƒåæ ‡è¿›è¡Œä½ç½®
                        OUT.positionOS = patch[0].positionOS * barycentricCoordinates.x + 
                                            patch[1].positionOS * barycentricCoordinates.y + 
                                            patch[2].positionOS * barycentricCoordinates.z;
                        //æ ¹æ®é‡å¿ƒåæ ‡æ’å…¥åˆ‡çº¿æ•°æ®
                        OUT.tangentOS = patch[0].tangentOS * barycentricCoordinates.x + 
                                          patch[1].tangentOS * barycentricCoordinates.y + 
                                          patch[2].tangentOS * barycentricCoordinates.z;
                        //æ ¹æ®é‡å¿ƒåæ ‡æ’å…¥UV   
                        OUT.uv = patch[0].uv * barycentricCoordinates.x + 
                                 patch[1].uv * barycentricCoordinates.y + 
                                 patch[2].uv * barycentricCoordinates.z;
            
                        return vert_AfterTess(OUT);
                    }
            
            
                    //==========================================
                    // å‡ ä½•ç€è‰²å™¨éƒ¨åˆ†
                    //==========================================
                    //ç”¨æ¥å®šä¹‰ç”Ÿæˆè‰å¶çš„ä½ç½®ï¼Œå°è£…å‡½æ•°æ–¹ä¾¿é‡å¤è°ƒç”¨
                    inline geometryOutput VertexOutput(float3 positionOS,float2 uv)
                    {
                        geometryOutput output;
                        output = (geometryOutput)0;
                        output.positionCS = TransformObjectToHClip(positionOS);
                        output.positionWS = TransformObjectToWorld(positionOS);
                        output.uv = uv;
                        output.shadowCoord = TransformWorldToShadowCoord(output.positionWS);    //ä¸–ç•Œåæ ‡è½¬æ¢åˆ°é˜´å½±åæ ‡
            
                        
                        return output;
                    }
            
                    inline geometryOutput VertexOutput(float3 positionOS,float2 uv,float3 normalOS)
                    {
                        geometryOutput output;
                        output = (geometryOutput)0;
                        output.positionCS = TransformObjectToHClip(positionOS);
                        output.positionWS = TransformObjectToWorld(positionOS);
                        output.uv = uv;
                        output.normalWS = TransformObjectToWorldNormal(normalOS);
                        output.shadowCoord = TransformWorldToShadowCoord(output.positionWS);    //ä¸–ç•Œåæ ‡è½¬æ¢åˆ°é˜´å½±åæ ‡
            
                        //å…‰ç…§æ•°æ®
                        Light mainLight = GetMainLight();
                        float3 lightDir = normalize(mainLight.direction).xyz;
            
                        //ç¡®ä¿åªåœ¨é˜´å½±é€šé“çš„æ—¶å€™æ‰è¿›è¡Œç¨å¾®çš„åç§»
                        #if UNITY_PASS_SHADOWCASTER
                        output.positionWS = float4(ApplyShadowBias(output.positionWS,output.normalWS,lightDir) , 1.0);
                        #endif
                        
                        return output;
                    }
            
                    //ç”¨äºæ›´åŠ ç®€ä¾¿çš„æ–¹å¼ä¹¦å†™çš„å°è£…å‡½æ•°
                    inline geometryOutput GenerateGrassVertex(float3 vertexPositionOS , float width , float height ,float forward , float3 normalOS , float2 uv , float3x3 transformationMatrix)
                    {
            
                        float3 tangentPoint = float3(width , forward , height);
            
                        //è‡ªç”Ÿæˆæ³•çº¿
                        //è·ŸåŸæ¥çš„å·®åˆ«å¾ˆå¤§ï¼ï¼ï¼
                        //åŸæ¥çš„ç”¨çš„éƒ½æ˜¯åº•éƒ¨çš„é¡¶ç‚¹çš„æ³•çº¿ï¼Œåœ¨è®¡ç®—å…‰ç…§çš„æ—¶å€™ä¼šé€ æˆæ³•çº¿çš„é”™è¯¯ã€‚
                        float3 normalTS = float3(0,-1,forward);
                        // float3 localNormalOS = mul( normalOS , transformationMatrix);
                        float3 localNormalOS = mul( normalTS , transformationMatrix);
            
                        float3 localPositionOS = vertexPositionOS + mul(tangentPoint , transformationMatrix);
            
                        return VertexOutput(localPositionOS,uv,localNormalOS);
                    }
            
                    //å‡ ä½•ç€è‰²å™¨ï¼ŒGeometryâ†’Vertex
                    [maxvertexcount(BLADE_SEGMENTS * 2 + 1)]
                    void geom(
                        triangle Tess_Varyings input[3],
                        inout TriangleStream<geometryOutput> triStream)
                    {
                        geometryOutput output;
                        output = (geometryOutput)0;
            
                        //å‚æ•°ä¼ å…¥
                        float3 positionOS = input[0].positionOS;
                        float3 positionWS = input[0].positionWS;
                        float3 normalOS = input[0].normalOS;
            
                        float4 tangentOS = input[0].tangentOS;
                        float3 BinormalOS = cross(normalOS, tangentOS.xyz) * tangentOS.w;
            
                        //éšæœºå®½é«˜
                        float height = (rand(positionOS.zyx) * 2 - 1) * _BladeHeightRandom + _BladeHeight  ;
                        float width = (rand(positionOS.xzy) * 2 - 1) * _BladeWidthRandom + _BladeWidth ;
                        float forward = rand(positionOS.yyz) * _BladeForward;
            
                        //UV
                        float2 uv = positionOS.xz * _WindDistortionMap_ST.xy + _WindDistortionMap_ST.zw + _WindFrequency.xy * _Time.y;
            
                        //Wind Construct
                        float2 windSample = SAMPLE_TEXTURE2D_LOD(_WindDistortionMap, sampler_WindDistortionMap, uv * 2 - 1, 0) * _WindStrength;
                        float3 wind = normalize(float3(windSample.x,windSample.y,0.0));//wind Vector
                        float3x3 windRotationMatrix = AngleAxis3x3(CUSTOM_PI * windSample,wind);
            
            
                        //éšæœºæ—‹è½¬è§’åº¦çŸ©é˜µ
                        float3x3 facingRotationMatrix = AngleAxis3x3(rand(positionOS + _RotateSeed.xyz ) * CUSTOM_TWO_PI, float3(0.0,0.0,1.0));
            
                        //éšæœºå¼¯æŠ˜çŸ©é˜µ
                        float3x3 bendRotationMatrix = AngleAxis3x3(rand(positionOS + _RotateSeed.yzx) * CUSTOM_PI * _BendRotationRandom * 0.5 , float3(-1.0,0.0,0.0));
            
                        //TBNçŸ©é˜µ
                        float3x3 TBN_T2O = float3x3(tangentOS.xyz,BinormalOS,normalOS);//åˆ—å‘é‡æ’å¸ƒ
            
                        //çŸ©é˜µçš„æ··åˆï¼ˆéœ€è€ƒè™‘é¡ºåºï¼‰
                        float3x3 transformationMatrix = mul(windRotationMatrix,mul(facingRotationMatrix,mul(bendRotationMatrix,TBN_T2O)));
                        float3x3 transformationMatrixFacing = mul(facingRotationMatrix,TBN_T2O);//ç”¨äºåº•éƒ¨çš„ä¸¤ä¸ªé¡¶ç‚¹ç‰¹æ®Šå¤„ç†ï¼Œä¸è®©å…¶é£åŠ¨å’Œå¼¯æ›²
                        
             
                        //ä¸‰è§’å½¢é¡¶ç‚¹çš„å¢åŠ 
                        for(int i = 0; i < BLADE_SEGMENTS; i++)
                        {
                            float t = i / (float)BLADE_SEGMENTS;
                            float segmentHeight = height * t;
                            float segmentWidth = width * (1 - t);
            
                            float segmentForward = forward * pow(t , _BladeCurve);
            
                            //åº•éƒ¨çš„ä¸¤ä¸ªé¡¶ç‚¹ä¸åŠ¨ï¼Œä¹Ÿå°±æ˜¯i = 0çš„æƒ…å†µ
                            float3x3 transformationMatrix_T = i == 0 ? transformationMatrixFacing : transformationMatrix;   
                            triStream.Append(GenerateGrassVertex(positionOS , segmentWidth , segmentHeight , segmentForward , normalOS , float2(0.0,t) , transformationMatrix_T));//ä¸¤ä¸ªåº•éƒ¨çš„é¡¶ç‚¹ä¸åšé£åŠ¨æ•ˆæœä»¥åŠå¼¯æŠ˜
                            triStream.Append(GenerateGrassVertex(positionOS , -segmentWidth , segmentHeight , segmentForward , normalOS , float2(1.0,t) , transformationMatrix_T));
                        }
                        //æœ€åä¸€ä¸ªé¡¶ç‚¹çš„ä¸‰è§’å½¢
                        triStream.Append(GenerateGrassVertex(positionOS , 0.0 , height , forward , normalOS , float2(0.5,1.0) , transformationMatrix));  
                        
                    }
            
                    //==========================================
                    // åŸå§‹çš„ç‰‡æ®µç€è‰²å™¨ï¼ŒVertexâ†’Fragment
                    //==========================================
                    half4 frag_Common (geometryOutput input,half facing:VFACE) : SV_Target
                    {
                        float3 normalWS = facing > 0 ? input.normalWS : -input.normalWS;
            
                        //é˜´å½±æ•°æ®
                        float4 shadowCoord = input.shadowCoord;
                        half shadow = MainLightRealtimeShadow(shadowCoord); 
            
                        //å…‰ç…§æ•°æ®
                        Light mainLight = GetMainLight();
                        float3 lightDir = normalize(mainLight.direction).xyz;
            
                        float NdotL = saturate(dot(normalWS, lightDir)) * shadow;
            
                        float3 ambient = SampleSH(normalWS);
                        float4 lightTerm = float4(( NdotL * mainLight.color + ambient)  , 1.0);
            
                        half4 color = lerp(_BottomColor, _TopColor * lightTerm , input.uv.y);
            
                        return color ;
            
                    }
            
                    float4 frag_ShadowCaster (geometryOutput input) : SV_Target
                    {
                        float4 shadowCoord = input.shadowCoord;
            
                        half shadow = MainLightRealtimeShadow(shadowCoord); 
            
                        return shadow;
                    }
            
                    ENDHLSL
            
                    Pass
                    {
                        Name "TessGeo_Grass"
                        
                        Tags 
                        { 
                            "LightMode" = "UniversalForward"
                        }
            
                        HLSLPROGRAM
            
                        #pragma vertex vert_Tess
                        #pragma hull hull_Tess
                        #pragma domain domain_Tess
                        #pragma geometry geom
                        #pragma fragment frag_Common
            
            
            
            
                        ENDHLSL
                    }
            
                    Pass
                    {
                        Tags
                        {
                            "LightMode" = "ShadowCaster"
                        }
            
                        HLSLPROGRAM
            
                        #pragma vertex vert_Tess
                        #pragma hull hull_Tess
                        #pragma domain domain_Tess
                        #pragma geometry geom
                        #pragma fragment frag_ShadowCaster
                        #pragma multi_compile_shadowcaster
            
                        
            
                        ENDHLSL
            
                    }
                }
            }
            ```

10. **ä¸è‰çš„äº¤äº’**

   - å‚è€ƒä¸è‰çš„äº¤äº’ï¼š[BIRP - å…·æœ‰äº¤äº’æ€§çš„è‰åœ°å‡ ä½•ç€è‰²å™¨ |Patreon å…¬å¸](https://www.patreon.com/posts/grass-geometry-1-40090373)

   - **æ ¸å¿ƒä»£ç **

      - ```C
         //_PositionMovingæ˜¯ä»CPUç«¯ä¼ å…¥è¿‡æ¥çš„ç‰©ä½“çš„ä½ç½®
         //ç®€å•çš„äº¤äº’æ•ˆæœâ€”â€”è·ç¦»è®¡ç®—
         float3 dis = distance(_PositionMoving , positionWS);    //ä¸é¡¶ç‚¹çš„åŠå¾„è·ç¦»
         float3 radiusFalloff = 1 - saturate(dis / _Radius);    //å’Œé¡¶ç‚¹çš„åŠå¾„è¡°å‡
         float3 sphereDisp = positionWS - _PositionMoving;  //ç§»åŠ¨ä½ç½®æŒ‡å‘é¡¶ç‚¹
         sphereDisp *= radiusFalloff  * 0.5;//è¡°å‡è·ç¦»ï¼Œä¹˜0.5æ•ˆæœå¥½ä¸€ç‚¹
         sphereDisp = clamp(sphereDisp, -0.8, 0.8);
         ```

         - å¯¹é¡¶ç‚¹äº¤äº’çš„ä½ç½®è¿›è¡Œå½±å“åŒºåŸŸç•Œå®š

      - ç„¶åç»„è£…åˆ°ä¼ å…¥è¿‡å»çš„ç‰©ä½“ä½ç½®å³å¯

         - ```C
            //-----å†™åœ¨forå¾ªç¯é‡Œé¢
            //å°è¯•ç›´æ¥ä¿®æ”¹é¡¶ç‚¹ä½ç½®
            float3 newPositionOS = i == 0 ? positionOS : positionOS + sphereDisp  * t;//ä¸¤ä¸ªåº•éƒ¨çš„é¡¶ç‚¹ä¸åšé£åŠ¨æ•ˆæœä»¥åŠå¼¯æŠ˜
            triStream.Append(GenerateGrassVertex(newPositionOS , segmentWidth , segmentHeight , segmentForward , normalOS , float2(0.0,t) , transformationMatrix_T));
            triStream.Append(GenerateGrassVertex(newPositionOS , -segmentWidth , segmentHeight , segmentForward , normalOS , float2(1.0,t) , transformationMatrix_T));
            ```

      - **C#ç«¯ç®€å•çš„ä»£ç **

         - ```c#
            void Update()
                {
                    Shader.SetGlobalVector("_PositionMoving", transform.position);
                }
            ```

      - **æ•ˆæœæ¼”ç¤º**

         - ![åŠ¨ç”»](D:/TyporaImage/%E5%8A%A8%E7%94%BB-1739540144418-10.gif)

11. **åšå¾—æ›´å¥½**

    - å¯ä»¥å¯¹äºæ°´ä½“åº”ç”¨æ›²é¢ç»†åˆ†ï¼Œå¯ä»¥å¢åŠ è·ç¦»å› ç´ ã€‚æ ¹æ®è·ç¦»åŠ¨æ€è°ƒæ•´`Tessellation Factor`



#### æ›²é¢ç»†åˆ†ç”Ÿæˆäº¤äº’é›ªåœ°æ¡ˆä¾‹

å‚è€ƒåŸºç¡€å®ç°ï¼š[URP-Shaderæ¡ˆä¾‹ä¸‰ï¼šé›ªåœ°è½¨è¿¹æ•ˆæœ - çŸ¥ä¹ (zhihu.com)](https://zhuanlan.zhihu.com/p/369110873)

1. å®Œæ•´çš„å®ç°æ›²é¢ç»†åˆ†æ•ˆæœï¼Œå¹¶ä¸”ç¡®ä¿èƒ½å¤Ÿè¯»å–**Albedoè´´å›¾**ï¼Œ**æ³•çº¿è´´å›¾**ä»¥åŠ**Displacementè´´å›¾**

2. **å®Œæˆä¸€ä¸ªå¯ä»¥é’ˆå¯¹ä¸åŒçš„uvçº¹ç†åæ ‡è·ç¦»ï¼Œè¿›è¡Œç›¸åº”çš„ç»˜åˆ¶çš„Shader**

   - ä»£ç 

     ```c#
                 float4 frag (v2f i) : SV_Target
                 {
                     float4 col = _MainTex.Sample(smp, i.uv);
                     float draw = pow(saturate(1 - distance(i.uv, _Coordinate.xy)), _DrawStength);
                     float4 drawCol = _Color * draw;
                     return col + drawCol;
                 }
     ```

3. **ç¼–è¾‘C#ä»£ç **è¿›è¡Œæ•°æ®ä¼ é€’

   - ä»£ç 

     ```C#
     using System.Collections;
     using System.Collections.Generic;
     using UnityEngine;
     public class DrawTrack : MonoBehaviour
     {
         [SerializeField] private Material DrawMat;
         [SerializeField] private Material LandMat;
         private RenderTexture TrackRT;
         private Transform m_LastPos = null;
         public float DrawStength = 1.0f;
         public Color DrawColor = Color.white;
         void Start()
         {
             m_LastPos = transform;
             TrackRT = new RenderTexture(2048, 2048, 0, RenderTextureFormat.Default);
         }
         // Update is called once per frame
         void Update()
         {
             DrawMat.SetFloat("_DrawStength", DrawStength); //è®¾ç½®ç»˜åˆ¶å¼ºåº¦
             DrawMat.SetColor("_Color", DrawColor); //è®¾ç½®ç»˜åˆ¶é¢œè‰²
             if (Physics.Raycast(transform.position, Vector3.down, out RaycastHit hit, 10)) //zè½´å‘ä¸‹å°„çº¿æ£€æµ‹åœ°é¢
             {
                 DrawMat.SetVector("_Coordinate", new Vector4(hit.textureCoord.x, hit.textureCoord.y, 0, 0)); //è®¾ç½®çº¹ç†åæ ‡
                 RenderTexture tmp = RenderTexture.GetTemporary(TrackRT.width, TrackRT.height, 0, RenderTextureFormat.Default); //åˆ›å»ºä¸´æ—¶æ¸²æŸ“çº¹ç†
                 Graphics.Blit(TrackRT, tmp);
                 Graphics.Blit(tmp, TrackRT, DrawMat); //ç»˜åˆ¶è½¨è¿¹
                 RenderTexture.ReleaseTemporary(tmp); //é‡Šæ”¾ä¸´æ—¶æ¸²æŸ“çº¹ç†
                 LandMat.SetTexture("_SunkenMap", TrackRT); //è®¾ç½®çº¹ç†è´´å›¾
             }
             m_LastPos.position = transform.position;
         }
     }
     
     ```

4. **å®ç°æ•ˆæœ**

   - ![åŠ¨ç”»](D:/TyporaImage/%E5%8A%A8%E7%94%BB-1739628316724-5.gif)

5. **ä¸è¶³**

   - æˆ‘æ²¡æœ‰åšå¯¹äºç¢°æ’ç‰©çš„ä½“ç§¯æ£€æµ‹
   - é›ªåœ°æ˜¯åˆæ­¥çš„æ¸²æŸ“æ•ˆæœï¼Œä¸çœŸå®

6. **åšå¾—æ›´å¥½**

   - [Unity-é›ªåœ°æ•ˆæœçš„å®ç° - çŸ¥ä¹ (zhihu.com)](https://zhuanlan.zhihu.com/p/110447928)â€”â€”è¿™ç¯‡æ–‡ç« è®²äº†ç»˜åˆ¶æ›´å¤šçš„é€šé“ï¼Œæ ¹æ®è®¡ç®—åçš„æ·±åº¦å€¼å›¾ï¼Œè¿›è¡Œä¸¤æ¬¡è½®å»“çº¿æ£€æµ‹ï¼Œé‡‡ç”¨çš„æ˜¯æœ€åŸºæœ¬ç®€å•çš„sobelç®—å­ï¼Œç„¶åç”¨gå’Œbé€šé“åˆ†åˆ«å­˜å‚¨å…¶é¢œè‰²ã€‚è¿™æ ·åšçš„ç›®çš„æ˜¯ï¼Œå¯ä»¥æ ¹æ®æœ€åçš„æ·±åº¦å›¾çš„ä¸åŒé€šé“ï¼Œå°†é›ªåœ°åˆ†ä¸ºåŸºæœ¬é›ªé¢ï¼ˆæ— é¢œè‰²å€¼ï¼‰ã€å‡¸èµ·éƒ¨åˆ†ï¼ˆgé€šé“ï¼‰ã€ä¾§è¾¹ï¼ˆbé€šé“ï¼‰ã€å‡¹é™·åº•éƒ¨ï¼ˆaé€šé“ï¼‰å››ä¸ªéƒ¨åˆ†ã€‚é€šè¿‡å·ç§¯æ ¸å¯¹å›¾åƒçš„å¤„ç†ï¼Œæ‹“å®½è¾¹ç¼˜ç­‰æ–¹æ³•ã€‚<img src="D:/TyporaImage/v2-e32657dcc00c83b1ba91a0581fc148ee_1440w.jpg" alt="img" style="zoom:25%;" />
   - [UnityåŠ¨æ€é›ªåœ°ï¼ˆæ²™åœ°ï¼‰ - çŸ¥ä¹ (zhihu.com)](https://zhuanlan.zhihu.com/p/353196002)â€”â€”è¿™ç¯‡æ–‡ç« æåˆ°äº†ä½¿ç”¨Compute Shaderçš„æ–¹å¼å®ç°ï¼Œå¯¹è±¡æ˜¯äººç‰©ï¼Œæåˆ°äº†åŒæ‘„åƒå¤´çš„åŠ¨æ€æ•æ‰ã€‚è€Œä¸”æ˜¯é¢å‘äº3Aå¤§ä½œé‡Œé¢çš„é›ªåœ°å®ç°æ€è·¯ã€‚<img src="D:/TyporaImage/v2-807d19ff3760142752b2f4f2635c76b0_r.jpg" alt="img" style="zoom: 33%;" />
   - [å…¥é—¨å›¾å½¢å­¦ï¼šé›ªåœ°ç‰¹æ•ˆï¼ˆä¸€ï¼‰_unityé›ªåœ°-CSDNåšå®¢](https://blog.csdn.net/yinhun2012/article/details/119983949)â€”â€”å¾ˆé€‚åˆæ–°æ‰‹ï¼Œå¾ˆè¯¦ç»†çš„æåˆ°äº†ä»é¡¶éƒ¨æ‘„åƒæœºçš„ç…§å°„ï¼Œæ ¹æ®ä½“ç§¯çš„ä¸‹é™·ï¼Œè€Œä¸”æœ‰å®Œæ•´çš„ä»£ç ã€‚![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](D:/TyporaImage/e5cb75aeeed108b9ec12875405c0c3dc.gif)
   - [unityé›ªæ™¯æ¸²æŸ“é€‚åˆä½œä¸ºæ¯•ä¸šè®¾è®¡å—ï¼Ÿ - çŸ¥ä¹ (zhihu.com)](https://www.zhihu.com/question/687741199/answer/4973003160)â€”â€”ç”šè‡³èƒ½æ‹¿æ¥å½“æ¯•è®¾ï¼Ÿ

7. **å®Œæ•´ä»£ç **

   - å¤ªé•¿äº†ä¸æ”¾äº†â€¦â€¦æœ‰æœºä¼šä¸Šä¼ åˆ°Githubè‡ªå–å§
